#include "../../../ray.conf"
#include "../../../ray_advanced.conf"
#include "../../../shader/math.fxsub"
#include "../../../shader/common.fxsub"
#include "../../../shader/shadowcommon.fxsub"
#include "../../../shader/gbuffer.fxsub"
#include "../../../shader/gbuffer_sampler.fxsub"
#include "../../../shader/PhaseFunctions.fxsub"
#include "../../../shader/lighting.fxsub"
#include "../../../shader/arealight.fxsub"

float mR : CONTROLOBJECT<string name="(self)"; string item = "R+";>;
float mG : CONTROLOBJECT<string name="(self)"; string item = "G+";>;
float mB : CONTROLOBJECT<string name="(self)"; string item = "B+";>;
float mRangeP : CONTROLOBJECT<string name="(self)"; string item = "Range+";>;
float mRangeM : CONTROLOBJECT<string name="(self)"; string item = "Range-";>;
float mIntensityP : CONTROLOBJECT<string name="(self)"; string item = "Intensity+";>;
float mIntensityM : CONTROLOBJECT<string name="(self)"; string item = "Intensity-";>;
float mAngleM : CONTROLOBJECT<string name = "(self)"; string item = "Angle-";>;
float mBlink : CONTROLOBJECT<string name="(self)"; string item = "Blink";>;
float mAttenuationBulbP : CONTROLOBJECT<string name = "(self)"; string item = "AttenuationBulb+";>;
float mAttenuationBulbM : CONTROLOBJECT<string name = "(self)"; string item = "AttenuationBulb-";>;
float mMiePhaseP : CONTROLOBJECT<string name="(self)"; string item = "MiePhase+";>;
float mMiePhaseM : CONTROLOBJECT<string name="(self)"; string item = "MiePhase-";>;
float mMieDensityP : CONTROLOBJECT<string name="(self)"; string item = "MieDensity+";>;
float mMieDensityM : CONTROLOBJECT<string name="(self)"; string item = "MieDensity-";>;

float3 mPosition : CONTROLOBJECT<string name="(self)"; string item = "Position";>;
float3 mDirection : CONTROLOBJECT<string name = "(self)"; string item = "Direction";>;

static const float FogBlink = saturate(1 - SmoothTriangleWave(time * mBlink * 10));
static const float FogAngle = radians(lerp(FogAngleParams.x, FogAngleParams.y, mAngleM));
static const float FogMiePhase  = lerp(lerp(FogMieParams.x, FogMieParams.z, mMiePhaseP), FogMieParams.y, mMiePhaseM);
static const float FogRange = lerp(lerp(FogRangeParams.x, FogRangeParams.z, mRangeP), FogRangeParams.y, mRangeM);
static const float FogDensity = lerp(lerp(FogDensityParams.x, FogDensityParams.z, mMieDensityP), FogDensityParams.y, mMieDensityM);
static const float FogIntensity = lerp(lerp(FogIntensityParams.x, FogIntensityParams.z, mIntensityP), FogIntensityParams.y, mIntensityM);
static const float FogAttenuationBulb = lerp(lerp(FogAttenuationBulbParams.x, FogAttenuationBulbParams.z, mAttenuationBulbP), FogAttenuationBulbParams.y, mAttenuationBulbM);

static const float3 FogPosition = mPosition;
static const float3 FogDirection = normalize(mDirection - mPosition);
static const float3 FogColor = float3(mR, mG, mB) * FogIntensity * FogBlink;

static const float3 viewFogPosition = mul(float4(mDirection, 1), matView).xyz;
static const float3 viewFogDirection = normalize(mul(-FogDirection, (float3x3)matView));

static float4x4 matLightProject = CreatePerspectiveProject(FogAngle, 1, mLightPlaneNear, mLightPlaneFar);
static float4x4 matLightView = CreateLightViewMatrix(FogDirection, FogPosition);
static float4x4 matLightViewProject = mul(matLightView, matLightProject);
static float4x4 matLightViewFromCameraView = mul(matViewInverse, matLightView);
static float4x4 matLightProjectFromCameraView = mul(matViewInverse, matLightViewProject);

struct FogParam
{
	float3 eye;

	float3 FogPosition;
	float3 FogColor;

	float FogRange;
	float FogDensity;
	float FogIntensity;
	float FogMiePhase;
	float FogAttenuationBulb;
};

float ComputeOpticalDepth(FogParam param, float depth)
{
	return exp(-depth * param.FogDensity);
}

float ComputeScatteringExtinction(FogParam param, float depth)
{
	return (1 - exp(-depth * param.FogDensity));
}

#if VOLUMETRIC_FOG_ENABLE
#if VOLUMETRIC_FOG_QUALITY == 0
#	define VOLUMETRIC_FOG_SIZE 256
#elif VOLUMETRIC_FOG_QUALITY == 1
#	define VOLUMETRIC_FOG_SIZE 512
#elif VOLUMETRIC_FOG_QUALITY >= 2
#	define VOLUMETRIC_FOG_SIZE 1024
#elif VOLUMETRIC_FOG_QUALITY >= 3
#	define VOLUMETRIC_FOG_SIZE 2048
#else
#	define VOLUMETRIC_FOG_SIZE 256
#endif

texture VolumetricFog: OFFSCREENRENDERTARGET <
	string Description = "Volumetric fog Rendering for SphereFog";
	int Width = VOLUMETRIC_FOG_SIZE;
	int Height = VOLUMETRIC_FOG_SIZE;
	string Format = "R32F";
	float4 ClearColor = { 1, 1, 1, 1 };
	float ClearDepth = 1.0;
	string DefaultEffect = 
		"self = hide;"
		"*fog.pmx=hide;"
		"*controller.pmx=hide;"
		"*.pmx = ../spot_fog_shadow.fx;"
		"*.pmd = ../spot_fog_shadow.fx;"
		"* = hide";
>;
sampler VolumetricFogSamp = sampler_state {
	texture = <VolumetricFog>;
	MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};

static float2 ShadowmapOffset  = 0.5 / VOLUMETRIC_FOG_SIZE;
static float2 ShadowmapOffset2 = 1.0 / VOLUMETRIC_FOG_SIZE;

float ShadowTest(FogParam param, sampler shadowMap, float3 viewPosition)
{
	float4 proj = mul(float4(viewPosition, 1), matLightProjectFromCameraView);
	proj.xy = PosToCoord(proj.xy / proj.w);
	proj.xy += ShadowmapOffset;

	float linearDepth = length(mul(float4(viewPosition, 1), matLightViewFromCameraView));
	return tex2Dlod(shadowMap, float4(proj.xy, 0, 0)).r < linearDepth ? 0 : 1;
}

float4 SphereFog(FogParam param, sampler shadowMap, float shadowSize, float3 viewdir, float depth, int stepNum)
{
	float3 viewPosition = viewdir * depth / viewdir.z;

	float stepLength = distance(viewPosition, viewdir);
	float stepSize = stepLength / stepNum;

	float3 stepDir = (viewPosition - viewdir) / stepLength;
	float3 step = stepDir * stepSize;
	float3 stepStart = viewdir + step;

	float scatteringMie = 0;
	float stepDepth = stepSize;

	for (int i = 0; i < stepNum; i++)
	{
		float3 L = viewFogPosition - stepStart;
		float3 Lnormalized = normalize(L);
		float atten = GetPhysicalLightAttenuation(L, param.FogRange, param.FogAttenuationBulb);
		atten *= ComputeScatteringExtinction(param, stepDepth);
		atten *= GetSpotLightAttenuation(Lnormalized, viewFogDirection, FogAngle, 2.0);
		atten *= ShadowTest(param, shadowMap, stepStart);
#if VOLUMETRIC_FOG_ANISOTROPY
		atten *= ComputePhaseMie(dot(-viewdir, Lnormalized), param.FogMiePhase);
#endif

		stepDepth += stepSize;
		stepStart += step;
		scatteringMie += atten;
	}

	float3 scattering = scatteringMie;
	scattering *= param.FogColor * param.FogIntensity;

	return float4(scattering, 0);
}
#endif

float4 SphereFog(FogParam param, float3 viewdir, float depth, int stepNum)
{
	float3 viewPosition = viewdir * depth / viewdir.z;

	float stepLength = distance(viewPosition, viewdir);
	float stepSize = stepLength / stepNum;

	float3 stepDir = (viewPosition - viewdir) / stepLength;
	float3 step = stepDir * stepSize;
	float3 stepStart = viewdir + step;

	float scatteringMie = 0;
	float stepDepth = stepSize;

	for (int i = 0; i < stepNum; i++)
	{
		float3 L = viewFogPosition - stepStart;
		float3 Lnormalized = normalize(L);
		float atten = GetPhysicalLightAttenuation(L, param.FogRange, param.FogAttenuationBulb);
		atten *= ComputeScatteringExtinction(param, stepDepth);
		atten *= GetSpotLightAttenuation(Lnormalized, viewFogDirection, FogAngle, 2.0);
#if VOLUMETRIC_FOG_ANISOTROPY
		atten *= ComputePhaseMie(dot(-viewdir, Lnormalized), param.FogMiePhase);
#endif

		stepDepth += stepSize;
		stepStart += step;
		scatteringMie += atten;
	}

	float3 scattering = scatteringMie;
	scattering *= param.FogColor * param.FogIntensity;

	return float4(scattering, 0);
}

void SphereFogVS(
	in float4 Position : POSITION,
	in float3 Normal : NORMAL,
	in float2 Texcoord : TEXCOORD0,
	out float4 oTexcoord0 : TEXCOORD0,
	out float4 oTexcoord1 : TEXCOORD1,
	out float4 oPosition  : POSITION)
{
	float dist = distance(Position.xyz, FogPosition);
	float3 scale = Position.xyz + normalize(Position.xyz - mDirection) * (1.2 + FogAngle);

	Position.xyz = dist < 0.1 ? Position.xyz : lerp(mDirection, scale, FogAngle);
	Position.xyz = FogPosition + (Position.xyz - FogPosition) * FogRange / 2;

	oTexcoord1 = -mul(Position, matView);
	oTexcoord0 = oPosition = mul(Position, matViewProject);
	oTexcoord0.xy = PosToCoord(oTexcoord0.xy / oTexcoord0.w) + ViewportOffset;
	oTexcoord0.xy = oTexcoord0.xy * oTexcoord0.w;
}

float4 SphereFogPS(float4 texcoord : TEXCOORD0, float3 viewdir : TEXCOORD1) : COLOR
{
	float2 coord = texcoord.xy / texcoord.w;

	float4 MRT5 = tex2Dlod(Gbuffer5Map, float4(coord, 0, 0));
	float4 MRT6 = tex2Dlod(Gbuffer6Map, float4(coord, 0, 0));
	float4 MRT7 = tex2Dlod(Gbuffer7Map, float4(coord, 0, 0));
	float4 MRT8 = tex2Dlod(Gbuffer8Map, float4(coord, 0, 0));

	MaterialParam material;
	DecodeGbuffer(MRT5, MRT6, MRT7, MRT8, material);

	float3 V = normalize(viewdir);

	FogParam param;
	param.FogPosition = FogPosition;
	param.FogRange = FogRange;
	param.FogIntensity = FogIntensity;
	param.FogColor = FogColor;
	param.FogMiePhase = FogMiePhase;
	param.FogAttenuationBulb = FogAttenuationBulb;
	param.FogDensity = FogDensity;
	param.eye = CameraPosition;

#if VOLUMETRIC_FOG_ENABLE
	return SphereFog(param, VolumetricFogSamp, VOLUMETRIC_FOG_SIZE, V, material.linearDepth, VOLUMETRIC_FOG_SAMPLES_LENGTH);
#else
	return SphereFog(param, V, material.linearDepth, VOLUMETRIC_FOG_SAMPLES_LENGTH);
#endif
}

float4 SphereFogShadowlessPS(float4 texcoord : TEXCOORD0, float3 viewdir : TEXCOORD1) : COLOR
{
	float2 coord = texcoord.xy / texcoord.w;

	float4 MRT5 = tex2Dlod(Gbuffer5Map, float4(coord, 0, 0));
	float4 MRT6 = tex2Dlod(Gbuffer6Map, float4(coord, 0, 0));
	float4 MRT7 = tex2Dlod(Gbuffer7Map, float4(coord, 0, 0));
	float4 MRT8 = tex2Dlod(Gbuffer8Map, float4(coord, 0, 0));

	MaterialParam material;
	DecodeGbuffer(MRT5, MRT6, MRT7, MRT8, material);

	float3 V = normalize(viewdir);

	FogParam param;
	param.FogPosition = FogPosition;
	param.FogRange = FogRange;
	param.FogIntensity = FogIntensity;
	param.FogColor = FogColor;
	param.FogMiePhase = FogMiePhase;
	param.FogAttenuationBulb = FogAttenuationBulb;
	param.FogDensity = FogDensity;
	param.eye = CameraPosition;

	return SphereFog(param, V, material.linearDepth, VOLUMETRIC_FOG_SAMPLES_LENGTH);
}

technique MainTech0<string MMDPass = "object"
;>{
	pass DrawObject {
		ZEnable = false; ZWriteEnable = false;
		AlphaBlendEnable = TRUE; AlphaTestEnable = FALSE;
		SrcBlend = ONE; DestBlend = ONE;
		CullMode = CW;
		VertexShader = compile vs_3_0 SphereFogVS();
		PixelShader  = compile ps_3_0 SphereFogShadowlessPS();
	}
}

technique MainTechBS0<string MMDPass = "object_ss"
;>{
	pass DrawObject {
		ZEnable = false; ZWriteEnable = false;
		AlphaBlendEnable = TRUE; AlphaTestEnable = FALSE;
		SrcBlend = ONE; DestBlend = ONE;
		CullMode = CW;
		VertexShader = compile vs_3_0 SphereFogVS();
		PixelShader  = compile ps_3_0 SphereFogPS();
	}
}

technique EdgeTec<string MMDPass = "edge";> {}
technique ShadowTech<string MMDPass = "shadow";>{}
technique ZplotTec<string MMDPass = "zplot";>{}