#include "../../ray.conf"
#include "../../shader/math.fx"
#include "../../shader/common.fx"
#include "../../shader/gbuffer.fx"
#include "../../shader/gbuffer_sampler.fx"
#include "../../shader/lighting.fx"

float EnvRotateX : CONTROLOBJECT < string name="ray_controller.pmx"; string item = "EnvRotateX"; >;
float EnvRotateY : CONTROLOBJECT < string name="ray_controller.pmx"; string item = "EnvRotateY"; >;
float EnvRotateZ : CONTROLOBJECT < string name="ray_controller.pmx"; string item = "EnvRotateZ"; >;

static float rotateX = EnvRotateX * PI_2;
static float rotateY = EnvRotateY * PI_2;
static float rotateZ = EnvRotateZ * PI_2;
static float3x3 rotate = makeRotate(rotateX, rotateY, rotateZ);

texture IBLDiffuseTexture: MATERIALTOONTEXTURE;
sampler IBLDiffuseSampler = sampler_state {
    texture = <IBLDiffuseTexture>;
    
#if TEXTURE_ANISOTROPY > 0
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MAXANISOTROPY = TEXTURE_ANISOTROPY;
#else
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
#endif

    MIPFILTER = NONE;
    
    ADDRESSU  = CLAMP;  
    ADDRESSV  = CLAMP;
};

texture IBLSpecularTexture : MATERIALSPHEREMAP;
sampler IBLSpecularSampler = sampler_state {
    texture = <IBLSpecularTexture>;
    
#if TEXTURE_ANISOTROPY > 0
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MAXANISOTROPY = TEXTURE_ANISOTROPY;
#else
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
#endif

    MIPFILTER = LINEAR;
    
    ADDRESSU  = CLAMP;
    ADDRESSV  = CLAMP;
};

float mEnvLightP : CONTROLOBJECT < string name="ray_controller.pmx"; string item = "EnvLight+";>;
float mEnvLightM : CONTROLOBJECT < string name="ray_controller.pmx"; string item = "EnvLight-";>;
float mEnvSpecLightP : CONTROLOBJECT < string name="ray_controller.pmx"; string item = "EnvSpecLight+";>;
float mEnvSpecLightM : CONTROLOBJECT < string name="ray_controller.pmx"; string item = "EnvSpecLight-";>;

void LightingMaterial(float3 V, MaterialParam material, out float3 diffuse, out float3 specular)
{
    float3 worldNormal = mul(material.normal, (float3x3)matViewInverse);
    float3 worldView = V;

    float mipLayer = EnvironmentMip(material.smoothness, IBL_MIPMAP_LEVEL);

    float3 R = EnvironmentReflect(worldNormal, worldView);

    worldNormal = mul(rotate, worldNormal);
    R = mul(rotate, R);

#if IBL_QUALITY >= 2
    float4 prefilteredDiffuse = tex2D(IBLDiffuseSampler, computeSphereCoord(worldNormal));
    float4 prefilteredSpeculr = tex2Dlod(IBLSpecularSampler, float4(computeSphereCoord(R), 0, mipLayer));
    float4 prefilteredTransmittance = tex2D(IBLDiffuseSampler, -computeSphereCoord(worldNormal));
#else
    float4 prefilteredDiffuse = tex2Dlod(IBLSpecularSampler, float4(computeSphereCoord(worldNormal), 0, IBL_MIPMAP_LEVEL));
    float4 prefilteredSpeculr = tex2Dlod(IBLSpecularSampler, float4(computeSphereCoord(R), 0, mipLayer));
    float4 prefilteredTransmittance = tex2Dlod(IBLSpecularSampler, float4(computeSphereCoord(-worldNormal), 0, IBL_MIPMAP_LEVEL));
#endif

#if IBL_ENABLE_GAMMA_CORRECTION
    prefilteredDiffuse.rgb = srgb2linear(prefilteredDiffuse.rgb);
    prefilteredSpeculr.rgb = srgb2linear(prefilteredSpeculr.rgb);
    prefilteredTransmittance.rgb = srgb2linear(prefilteredTransmittance.rgb);
#endif

#if IBL_HDR_ENABLE
    prefilteredDiffuse.rgb = DecodeRGBM(prefilteredDiffuse);
    prefilteredSpeculr.rgb = DecodeRGBM(prefilteredSpeculr);
    prefilteredTransmittance.rgb = DecodeRGBM(prefilteredTransmittance);
#endif

    diffuse = prefilteredDiffuse.rgb * material.albedo + prefilteredTransmittance.rgb * material.transmittance;
    specular = prefilteredSpeculr.rgb * EnvironmentSpecularUnreal4(worldNormal, worldView, material.smoothness, material.specular);
}

void EnvLightingVS(
    in float4 Position : POSITION,
    in float3 Normal   : NORMAL,
    in float2 Texcoord : TEXCOORD0,
    out float4 oTexcoord  : TEXCOORD0,
    out float3 oNormal    : TEXCOORD1,
    out float3 oViewdir   : TEXCOORD2,
    out float4 oTexcoord2 : TEXCOORD3,
    out float4 oPosition  : SV_Position)
{
    oTexcoord = Texcoord.xyxy;
    oViewdir = CameraPosition - mul(Position, matWorld).xyz;
    oNormal = normalize(mul(Normal, (float3x3)matWorld));
    oPosition = mul(Position, matWorldViewProject);
    oTexcoord2 = oPosition;
}

float4 EnvLightingPS(
    float4 texcoord : TEXCOORD0,
    float3 normal   : TEXCOORD1,
    float3 viewdir  : TEXCOORD2,
    float4 texcoord2 : TEXCOORD3,
    float4 screenPosition : SV_Position) : SV_Target
{
    float2 coord = texcoord2.xy / texcoord2.w;
    coord = PosToCoord(coord);
    coord += ViewportOffset;

    float4 MRT1 = tex2D(Gbuffer1Map, coord);
    float4 MRT2 = tex2D(Gbuffer2Map, coord);
    float4 MRT3 = tex2D(Gbuffer3Map, coord);
    
    MaterialParam material;    
    DecodeGbuffer(MRT1, MRT2, MRT3, material);

    float3 V = normalize(viewdir);
    
#if (IBL_QUALITY >= 3) && (SSAO_SAMPLER_COUNT > 0)
    float4 lighting = float4(0.0, 0.5, 0.0, 0.5);
#else
    float4 lighting = 0.0f;
#endif
    
    float3 diffuse, specular;
    
    LightingMaterial(V, material, diffuse, specular);
    
#if ALHPA_ENABLE > 0
    float4 MRT5 = tex2D(Gbuffer5Map, coord);
    float4 MRT6 = tex2D(Gbuffer6Map, coord);
    float4 MRT7 = tex2D(Gbuffer7Map, coord);

    float alphaDiffuse = 0;
    MaterialParam materialAlpha;
    
    DecodeGbufferWithAlpha(MRT5, MRT6, MRT7, materialAlpha, alphaDiffuse);
    
    float3 diffuse2, specular2;
    LightingMaterial(V, materialAlpha, diffuse2, specular2);
    
    diffuse = lerp(diffuse, diffuse2, alphaDiffuse);
    specular = lerp(specular, specular2, alphaDiffuse);
#endif

#if (IBL_QUALITY >= 3) && (SSAO_SAMPLER_COUNT > 0)
    diffuse *= (lerp(1, 5, mEnvLightP) - mEnvLightM);
    specular *= (lerp(1, 5, mEnvSpecLightP) - mEnvSpecLightM);
    
    diffuse = rgb2ycbcr(diffuse);
    specular = rgb2ycbcr(specular);

    bool pattern = (fmod(screenPosition.x, 2.0) == fmod(screenPosition.y, 2.0));
    lighting.r = diffuse.r;
    lighting.g = (pattern) ? diffuse.g: diffuse.b;
    lighting.b = specular.r;
    lighting.a = (pattern) ? specular.g: specular.b;
#else
    lighting.rgb += diffuse * (lerp(1, 5, mEnvLightP) - mEnvLightM);
    lighting.rgb += specular * (lerp(1, 5, mEnvSpecLightP) - mEnvSpecLightM);
#endif

    return lighting;
}

#define OBJECT_TEC(name, mmdpass) \
    technique name < string MMDPass = mmdpass;\
    > { \
        pass DrawObject { \
            AlphaBlendEnable = FALSE; AlphaTestEnable = FALSE;\
            VertexShader = compile vs_3_0 EnvLightingVS(); \
            PixelShader  = compile ps_3_0 EnvLightingPS(); \
        } \
    }


OBJECT_TEC(MainTec0, "object")
OBJECT_TEC(MainTecBS0, "object_ss")

technique EdgeTec < string MMDPass = "edge"; > {}
technique ShadowTech < string MMDPass = "shadow";  > {}
technique ZplotTec < string MMDPass = "zplot"; > {}