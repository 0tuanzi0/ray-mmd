#include "shader/math.fxsub"
#include "shader/common.fxsub"

#if FOLLOW_POSITION == 0
	static const float3 LightPosition = -LightDirection * 80000;
#elif FOLLOW_POSITION == 1
	static const float3 LightPosition = AcsPosition;
#endif

texture ScnMap : RENDERCOLORTARGET <
	string Format = "A2B10G10R10";
>;
sampler2D ScnSamp = sampler_state {
	texture = <ScnMap>;
	MAGFILTER = POINT; MINFILTER = POINT; MIPFILTER = NONE;
	ADDRESSU = CLAMP; ADDRESSV = CLAMP;
};

#if LENSFLARE_MAP_FROM
	#if LENSFLARE_MAP_FROM == 1
		texture LensFlareMap<string ResourceName = LENSFLARE_MAP_FILE; int Miplevels = 1;>;
	#else
		texture LensFlareMap : ANIMATEDTEXTURE<string ResourceName = LENSFLARE_MAP_FILE; int Miplevels = 1;>;
	#endif
	sampler LensFlareMapSamp = sampler_state
	{
		Texture = LensFlareMap;
		MAGFILTER = POINT; MINFILTER = POINT; MIPFILTER = NONE;
		ADDRESSU = CLAMP; ADDRESSV = CLAMP;
	};
#endif

#if GHOST_MAP_FROM
	#if GHOST_MAP_FROM == 1
		texture GhostMap<string ResourceName = GHOST_MAP_FILE; int Miplevels = 1;>;
	#else
		texture GhostMap : ANIMATEDTEXTURE<string ResourceName = GHOST_MAP_FILE; int Miplevels = 1;>;
	#endif
	sampler GhostMapSamp = sampler_state
	{
		Texture = GhostMap;
		MAGFILTER = POINT; MINFILTER = POINT; MIPFILTER = NONE;
		ADDRESSU = CLAMP; ADDRESSV = CLAMP;
	};
#endif

float3 SampleSpectrum(float x)
{
	float t = 3.0 * x - 1.5;
	return saturate(float3(-t, 1 - abs(t), t));
}

float3 ChromaticAberration(sampler source, float2 coord, float2 offset, int samples, float4 limits = float4(0,0,1,1))
{
	float3 color = 0.0;
	float3 weight = 0.0;
	float2 delta = offset / samples;

	[unroll]
	for (int i = 0; i < samples; i++, coord += delta)
	{
		coord = clamp(coord, limits.xy, limits.zw);
		
		float3 w = SampleSpectrum(float(i) / samples);
		weight += w;
		color += w * srgb2linear(tex2Dlod(source, float4(coord, 0, 0)).rgb);
	}

	return color / weight;
}

float2 GetGhostImagePos(float4 position, float scale, float scale2, float offset, float index)
{
	float4 screenPosition = mul(float4(LightPosition, 1), matViewProject);
	screenPosition.xyz /= screenPosition.w;

	if (screenPosition.w < 0) return 0;

	float2 deltaScreenPos = -normalize(screenPosition.xyz).xy;

	float2 posScale = float2(1, ViewportAspect);
	posScale *= (GhostAllScale.x + GhostAllScale.z * index) * scale;
	posScale *= lerp(0.5, dot(deltaScreenPos.xy, deltaScreenPos.xy) + 0.5, GhostAllScale.y * scale2);

	float2 pos = 0;
	pos = position.xy * posScale;
	pos += screenPosition.xy + deltaScreenPos.xy * (GhostAllOffset.x + (index - LENSFLARE_MAP_INDEX) * GhostAllOffset.y) * offset;

	return pos;
}

#if LENSFLARE_MAP_FROM
float4 LensflareVS(
	in float4 position : POSITION, 
	in float2 texcoord : TEXCOORD0, 
	out float2 oTexcoord0: TEXCOORD0,
	out float4 oTexcoord1: TEXCOORD1) : POSITION
{
	oTexcoord0 = texcoord;
	oTexcoord1 = float4(LightSpecular * GhostFlareParams.z, 0);
	return float4(GetGhostImagePos(position, GhostFlareParams.x, GhostFlareParams.y, 0, 1), 0, 1);
}

float4 LensflarePS(
	in float2 coord0 : TEXCOORD0,
	in float4 coord1 : TEXCOORD1) : COLOR
{
#if LENSFLARE_MAP_TYPE
	float3 test = tex2Dlod(LensFlareMapSamp, float4(coord0, 0, 0)).rgb;
	clip(test - 1e-5);

	float4 screenPosition = mul(float4(LightPosition, 1), matViewProject);
	screenPosition.x = 1 - screenPosition.x;
	screenPosition.xyz /= screenPosition.w;
	
	float2 deltaScreenPos = -normalize(screenPosition.xyz).xy * float2(ViewportAspect, 1);
	deltaScreenPos *= GhostAllColorShift.x;

	float3 color = ChromaticAberration(LensFlareMapSamp, coord0, deltaScreenPos, 8).rgb * coord1.xyz;
#else
	float3 color = srgb2linear(tex2Dlod(LensFlareMapSamp, float4(coord0, 0, 0)).rgb) * coord1.xyz;
#endif

#if FOLLOW_POSITION == 0
	color *= saturate(normalize(LightPosition).y);
#endif
	color = linear2srgb(color);

	return float4(color, luminance(color) * 0.5);
}
#endif

#if GHOST_MAP_FROM
float4 GhostImageVS(
	in float4 position: POSITION, 
	in float2 texcoord : TEXCOORD0, 
	out float2 oTexcoord0: TEXCOORD0,
	out float4 oTexcoord1: TEXCOORD1,
	out float4 oTexcoord2: TEXCOORD2,
	uniform int index) : POSITION
{
	oTexcoord0 = float2(index % 4, index / 4) * 0.25 + texcoord * 0.25;
	oTexcoord1 = float4(float2(index % 4, index / 4) * 0.25, float2(index % 4, index / 4) * 0.25 + 0.25);
	oTexcoord2.rgb = GhostParams[index].w * GhostAllBrightness.x;
	oTexcoord2.rgb += (index - LENSFLARE_MAP_INDEX) * GhostAllBrightness.y;
	oTexcoord2.rgb *= index == LENSFLARE_MAP_INDEX ? LightSpecular : 1;
	oTexcoord2.a = index;

	return float4(GetGhostImagePos(position, GhostParams[index].x, GhostParams[index].y, GhostParams[index].z, index), 0, 1);
}

float4 GhostImagePS(
	in float2 coord0: TEXCOORD0,
	in float4 coord1: TEXCOORD1,
	in float4 coord2 : TEXCOORD2) : COLOR
{
#if GHOST_MAP_TYPE
	float4 screenPosition = mul(float4(LightPosition, 1), matViewProject);
	screenPosition.x = 1 - screenPosition.x;
	screenPosition.xyz /= screenPosition.w;
	
	float2 deltaScreenPos = -normalize(screenPosition.xyz).xy * float2(ViewportAspect, 1);
	deltaScreenPos *= GhostAllColorShift.y;
	deltaScreenPos *= lerp(GhostAllColorShift.z, GhostAllColorShift.w, saturate(coord2.w / 16));
	deltaScreenPos *= GhostShiftParams[int(coord2.w)];

	float3 color = ChromaticAberration(GhostMapSamp, coord0, deltaScreenPos, 16, coord1) * coord2.xyz;
#else
	float3 color = srgb2linear(tex2Dlod(GhostMapSamp, float4(coord0, 0, 0)).rgb) * coord2.xyz;
#endif

#if FOLLOW_POSITION == 0
	color *= saturate(normalize(LightPosition).y);
#endif
	color = linear2srgb(color);

	return float4(color, luminance(color) * 0.5);
}
#endif

float4 ShowScreenVS(
	in float4 position: POSITION,
	in float4 texcoord: TEXCOORD,
	out float4 oTexcoord : TEXCOORD0) : POSITION
{
	oTexcoord = texcoord;
	return position;
}

float4 ShowScreenPS(in float2 coord: TEXCOORD0) : COLOR
{
	return tex2Dlod(ScnSamp, float4(coord, 0, 0));
}

int GhostCount = 16;
int GhostIndex = 0;

float4 ClearColor = 0.0;
float ClearDepth  = 1.0;

float Script : STANDARDSGLOBAL <
	string ScriptOutput = "color";
	string ScriptClass = "scene";
	string ScriptOrder = "postprocess";
> = 0.8;

technique OpticalLight<
	string Script = 
		"RenderColorTarget=ScnMap;"
		"RenderDepthStencilTarget=;"
		"ClearSetColor=ClearColor;"
		"ClearSetDepth=ClearDepth;"
		"Clear=Color;"
		"Clear=Depth;"
		"ScriptExternal=Color;"

		"RenderColorTarget=;"
		"Clear=Color;"
		"Clear=Depth;"
		"Pass=ShowScreen;"
#if LENSFLARE_MAP_FROM
		"Pass=GenLensflare;"
#endif
#if GHOST_MAP_FROM
		"LoopByCount=GhostCount;"
		"LoopGetIndex=GhostIndex;"
		"Pass=GenGhostImage;"
		"LoopEnd=;"
#endif
;>{
	pass ShowScreen<string Script= "Draw=Buffer;";>{
		AlphaBlendEnable = false; AlphaTestEnable = false;
		ZEnable = false; ZWriteEnable = false;
		CULLMODE = NONE;
		VertexShader = compile vs_3_0 ShowScreenVS();
		PixelShader  = compile ps_3_0 ShowScreenPS();
	}
#if LENSFLARE_MAP_FROM
	pass GenLensflare<string Script= "Draw=Buffer;";>
	{
		AlphaBlendEnable = true; AlphaTestEnable = false;
		ZEnable = false; ZWriteEnable = false;
		SrcBlend = ONE; DestBlend = INVSRCALPHA;
		CULLMODE = NONE;
		VertexShader = compile vs_3_0 LensflareVS();
		PixelShader  = compile ps_3_0 LensflarePS();
	}
#endif
#if GHOST_MAP_FROM
	pass GenGhostImage<string Script= "Draw=Buffer;";>
	{
		AlphaBlendEnable = true; AlphaTestEnable = false;
		ZEnable = false; ZWriteEnable = false;
		SrcBlend = ONE; DestBlend = INVSRCALPHA;
		CULLMODE = NONE;
		VertexShader = compile vs_3_0 GhostImageVS(GhostIndex);
		PixelShader  = compile ps_3_0 GhostImagePS();
	}
#endif
}