#include "shader/common.fxsub"

#if GHOST_MAP_TYPE == 0
	static const float3 LightPosition = -LightDirection * 80000;
#elif GHOST_MAP_TYPE == 1
	static const float3 LightPosition = AcsPosition;
#endif

texture ScnMap : RENDERCOLORTARGET <
	string Format = "A2B10G10R10";
>;
sampler2D ScnSamp = sampler_state {
	texture = <ScnMap>;
	MAGFILTER = LINEAR; MINFILTER = LINEAR; MIPFILTER = LINEAR;
	ADDRESSU = CLAMP; ADDRESSV = CLAMP;
};
texture LensFlareMap<string ResourceName = LENSFLARE_MAP_FILE;>;
sampler LensFlareMapSamp = sampler_state
{
	Texture = LensFlareMap;
	MAGFILTER = LINEAR; MINFILTER = LINEAR; MIPFILTER = LINEAR;
	ADDRESSU = CLAMP; ADDRESSV = CLAMP;
};
texture GhostMap<string ResourceName = GHOST_MAP_FILE;>;
sampler GhostMapSamp = sampler_state
{
	Texture = GhostMap;
	MAGFILTER = LINEAR; MINFILTER = LINEAR; MIPFILTER = LINEAR;
	ADDRESSU = CLAMP; ADDRESSV = CLAMP;
};

int GhostCount = 16;
int GhostIndex = 0;

float luminance(float3 rgb)
{
	return dot(rgb, float3(0.2126f, 0.7152f, 0.0722f));
}

float3 SampleSpectrum(float x)
{
	float t = 3.0 * x - 1.5;
	return saturate(float3(-t, 1 - abs(t), t));
}

float3 ChromaticAberration(sampler source, float2 coord, float2 offset, int samples)
{
	float3 totalColor = 0.0;
	float3 totalWeight = 0.0;
	float2 delta = offset / samples;

	[unroll]
	for (int i = 0; i < samples; i++, coord += delta)
	{
		float3 w = SampleSpectrum(float(i) / samples);

		totalWeight += w;
		totalColor += w * pow(tex2Dlod(source, float4(coord, 0, 0)).rgb, 2.2);
	}

	return totalColor / totalWeight;
}

float2 GetGhostImagePos(float4 position, float scale, float scale2, float offset, float index)
{
	float4 screenPosition = mul(float4(LightPosition, 1), matViewProject);
	screenPosition.xyz /= screenPosition.w;

	if (screenPosition.w < 0) return 0;

	float2 deltaScreenPos = -normalize(screenPosition.xyz).xy;

	float2 posScale = float2(1, ViewportAspect);
	posScale *= scale;
	posScale *= lerp(0.5, dot(deltaScreenPos.xy, deltaScreenPos.xy) + 0.5, scale2);

	float2 pos = 0;
	pos = position.xy * posScale;
	pos += screenPosition.xy + deltaScreenPos.xy * (index - 1) * 0.5 * offset;

	return pos;
}

float4 LensflareVS(
	in float4 position: POSITION, 
	in float2 texcoord : TEXCOORD0, 
	out float2 oTexcoord0: TEXCOORD0,
	out float4 oTexcoord1: TEXCOORD1) : POSITION
{
	oTexcoord0 = texcoord;
	oTexcoord1 = float4(LightSpecular * GhostFlareParams.w, 0);
	return float4(GetGhostImagePos(position, GhostFlareParams.x, GhostFlareParams.y, GhostFlareParams.z, 1), 0, 1);
}

float4 GhostImageVS(
	in float4 position: POSITION, 
	in float2 texcoord : TEXCOORD0, 
	out float2 oTexcoord0: TEXCOORD0,
	out float4 oTexcoord1: TEXCOORD1,
	uniform int index) : POSITION
{
	oTexcoord0 = float2(index % 4, index / 4) * 0.25;
	oTexcoord0 = oTexcoord0 + saturate(position.xy + 0.5) * 0.25;
	oTexcoord1 = float4((index == LENSFLARE_INDEX ? LightSpecular : 1) * GhostParams[index].w * GhostAllBrightness, index);

	return float4(GetGhostImagePos(position, GhostParams[index].x, GhostParams[index].y, GhostParams[index].z, index), 0, 1);
}

float4 LensflarePS(
	in float2 coord0: TEXCOORD0,
	in float4 coord1: TEXCOORD1) : COLOR
{
	float4 screenPosition = mul(float4(LightPosition, 1), matViewProject);
	screenPosition.x = 1 - screenPosition.x;
	screenPosition.xyz /= screenPosition.w;

	float2 deltaScreenPos = -normalize(screenPosition.xyz).xy;
	deltaScreenPos *= 0.02;

	float3 color = ChromaticAberration(LensFlareMapSamp, coord0, deltaScreenPos, 8).rgb * coord1.xyz;
#if GHOST_MAP_TYPE == 0
	color *= saturate(normalize(LightPosition).y);
#endif
	color = pow(color, 1.0 / 2.2);

	return float4(color, luminance(color) * 0.5);
}

float4 GhostImagePS(
	in float2 coord0: TEXCOORD0,
	in float4 coord1: TEXCOORD1) : COLOR
{
	float4 screenPosition = mul(float4(LightPosition, 1), matViewProject);
	screenPosition.x = 1 - screenPosition.x;
	screenPosition.xyz /= screenPosition.w;

	float2 deltaScreenPos = -normalize(screenPosition.xyz).xy;
	deltaScreenPos *= float2(0.035,0.035);

	float3 color = ChromaticAberration(GhostMapSamp, coord0, deltaScreenPos * lerp(0.2, 1, saturate(coord1.w / 16)), 24);
	color *= coord1.xyz;
#if GHOST_MAP_TYPE == 0
	color *= saturate(normalize(LightPosition).y);
#endif
	color = pow(color, 1.0 / 2.2);

	return float4(color, luminance(color) * 0.5);
}

float4 ShowScreenVS(
	in float4 position: POSITION,
	in float4 texcoord: TEXCOORD,
	out float4 oTexcoord : TEXCOORD0) : POSITION
{
	oTexcoord = texcoord;
	return position;
}

float4 ShowScreenPS(in float2 coord: TEXCOORD0) : COLOR
{
	return tex2Dlod(ScnSamp, float4(coord, 0, 0));
}

float4 ClearColor = 0.0;
float ClearDepth  = 1.0;

float Script : STANDARDSGLOBAL <
	string ScriptOutput = "color";
	string ScriptClass = "scene";
	string ScriptOrder = "postprocess";
> = 0.8;

technique OpticalLight<
	string Script = 
		"RenderColorTarget=ScnMap;"
		"RenderDepthStencilTarget=;"
		"ClearSetColor=ClearColor;"
		"ClearSetDepth=ClearDepth;"
		"Clear=Color;"
		"Clear=Depth;"
		"ScriptExternal=Color;"

		"RenderColorTarget=;"
		"Clear=Color;"
		"Clear=Depth;"
		"Pass=ShowScreen;"

		"Pass=GenLensflare;"

		"LoopByCount=GhostCount;"
		"LoopGetIndex=GhostIndex;"
		"Pass=GenGhostImage;"
		"LoopEnd=;"
;>{
	pass ShowScreen<string Script= "Draw=Buffer;";>{
		AlphaBlendEnable = false; AlphaTestEnable = false;
		ZEnable = False; ZWriteEnable = False;
		CULLMODE = NONE;
		VertexShader = compile vs_3_0 ShowScreenVS();
		PixelShader  = compile ps_3_0 ShowScreenPS();
	}
	pass GenLensflare<string Script= "Draw=Buffer;";>
	{
		AlphaBlendEnable = true; AlphaTestEnable = false;
		ZEnable = false; ZWriteEnable = false;
		SrcBlend = ONE; DestBlend = INVSRCALPHA;
		CULLMODE = NONE;
		VertexShader = compile vs_3_0 LensflareVS();
		PixelShader  = compile ps_3_0 LensflarePS();
	}
	pass GenGhostImage<string Script= "Draw=Buffer;";>
	{
		AlphaBlendEnable = true; AlphaTestEnable = false;
		ZEnable = false; ZWriteEnable = false;
		SrcBlend = ONE; DestBlend = INVSRCALPHA;
		CULLMODE = NONE;
		VertexShader = compile vs_3_0 GhostImageVS(GhostIndex);
		PixelShader  = compile ps_3_0 GhostImagePS();
	}
}