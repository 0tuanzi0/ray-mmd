#include "shader/common.fxsub"

#if GHOST_MAP_TYPE == 0
	static const float3 LightPosition = -LightDirection * 80000;
#elif GHOST_MAP_TYPE == 1
	static const float3 LightPosition = AcsPosition;
#endif

texture ScnMap : RENDERCOLORTARGET <
	string Format = "A2B10G10R10";
>;
sampler2D ScnSamp = sampler_state {
	texture = <ScnMap>;
	MAGFILTER = LINEAR; MINFILTER = LINEAR; MIPFILTER = NONE;
	ADDRESSU = CLAMP; ADDRESSV = CLAMP;
};
texture LensFlareMap<string ResourceName = LENSFLARE_MAP_FILE; int Miplevels = 1;>;
sampler LensFlareMapSamp = sampler_state
{
	Texture = LensFlareMap;
	MAGFILTER = LINEAR; MINFILTER = LINEAR; MIPFILTER = NONE;
	ADDRESSU = CLAMP; ADDRESSV = CLAMP;
};
texture GhostMap<string ResourceName = GHOST_MAP_FILE; int Miplevels = 1;>;
sampler GhostMapSamp = sampler_state
{
	Texture = GhostMap;
	MAGFILTER = LINEAR; MINFILTER = LINEAR; MIPFILTER = NONE;
	ADDRESSU = CLAMP; ADDRESSV = CLAMP;
};

int GhostCount = 16;
int GhostIndex = 0;

float luminance(float3 rgb)
{
	return dot(rgb, float3(0.2126f, 0.7152f, 0.0722f));
}

float3 srgb2linear(float3 rgb)
{
	return pow(rgb, 2.2);
}

float4 srgb2linear(float4 c)
{
	return float4(srgb2linear(c.rgb), c.a);
}

float3 linear2srgb(float3 srgb)
{
	return pow(srgb, 1.0 / 2.2);
}

float4 linear2srgb(float4 c)
{
	return float4(linear2srgb(c.rgb), c.a);
}

float3 SampleSpectrum(float x)
{
	float t = 3.0 * x - 1.5;
	return saturate(float3(-t, 1 - abs(t), t));
}

float3 ChromaticAberration(sampler source, float2 coord, float2 offset, int samples, float4 limits = float4(0,0,1,1))
{
	float3 color = 0.0;
	float3 weight = 0.0;
	float2 delta = offset / samples;

	[unroll]
	for (int i = 0; i < samples; i++, coord += delta)
	{
		coord = clamp(coord, limits.xy, limits.zw);
		
		float3 w = SampleSpectrum(float(i) / samples);
		weight += w;
		color += w * srgb2linear(tex2Dlod(source, float4(coord, 0, 0)).rgb);
	}

	return color / weight;
}

float2 GetGhostImagePos(float4 position, float scale, float scale2, float offset, float index)
{
	float4 screenPosition = mul(float4(LightPosition, 1), matViewProject);
	screenPosition.xyz /= screenPosition.w;

	if (screenPosition.w < 0) return 0;

	float2 deltaScreenPos = -normalize(screenPosition.xyz).xy;

	float2 posScale = float2(1, ViewportAspect);
	posScale *= (GhostAllScale.x + GhostAllScale.z * index) * scale;
	posScale *= lerp(0.5, dot(deltaScreenPos.xy, deltaScreenPos.xy) + 0.5, GhostAllScale.y * scale2);

	float2 pos = 0;
	pos = position.xy * posScale;
	pos += screenPosition.xy + deltaScreenPos.xy * (GhostAllOffset.x + (index - LENSFLARE_INDEX) * GhostAllOffset.y) * offset;

	return pos;
}

float4 LensflareVS(
	in float4 position: POSITION, 
	in float2 texcoord : TEXCOORD0, 
	out float2 oTexcoord0: TEXCOORD0,
	out float4 oTexcoord1: TEXCOORD1) : POSITION
{
	oTexcoord0 = texcoord;
	oTexcoord1 = float4(LightSpecular * GhostFlareParams.w, 0);
	return float4(GetGhostImagePos(position, GhostFlareParams.x, GhostFlareParams.y, GhostFlareParams.z, 1), 0, 1);
}

float4 GhostImageVS(
	in float4 position: POSITION, 
	in float2 texcoord : TEXCOORD0, 
	out float2 oTexcoord0: TEXCOORD0,
	out float4 oTexcoord1: TEXCOORD1,
	out float4 oTexcoord2: TEXCOORD2,
	uniform int index) : POSITION
{
	oTexcoord0 = float2(index % 4, index / 4) * 0.25;
	oTexcoord0 = oTexcoord0 + saturate(position.xy + 0.5) * 0.25;
	oTexcoord1 = float4(float2(index % 4, index / 4) * 0.25, float2(index % 4, index / 4) * 0.25 + 0.25);
	oTexcoord2.rgb = GhostParams[index].w * GhostAllBrightness.x;
	oTexcoord2.rgb += (index - LENSFLARE_INDEX) * GhostAllBrightness.y;
	oTexcoord2.rgb *= index == LENSFLARE_INDEX ? LightSpecular : 1;
	oTexcoord2.a = index;

	return float4(GetGhostImagePos(position, GhostParams[index].x, GhostParams[index].y, GhostParams[index].z, index), 0, 1);
}

float4 LensflarePS(
	in float2 coord0 : TEXCOORD0,
	in float4 coord1 : TEXCOORD1) : COLOR
{
#if LENSFLARE_COLOR_SHIFT_ENABLE
	float3 test = tex2Dlod(LensFlareMapSamp, float4(coord0, 0, 0)).rgb;
	clip(test - 1e-5);

	float4 screenPosition = mul(float4(LightPosition, 1), matViewProject);
	screenPosition.xyz /= screenPosition.w;
	
	float2 deltaScreenPos = -normalize(screenPosition.xyz).xy;
	deltaScreenPos *= GhostAllColorShift.x;

	float3 color = ChromaticAberration(LensFlareMapSamp, coord0, deltaScreenPos, 8).rgb * coord1.xyz;
#else
	float3 color = srgb2linear(tex2Dlod(LensFlareMapSamp, float4(coord0, 0, 0)).rgb) * coord1.xyz;
#endif

#if GHOST_MAP_TYPE == 0
	color *= saturate(normalize(LightPosition).y);
#endif
	color = linear2srgb(color);

	return float4(color, luminance(color) * 0.5);
}

float4 GhostImagePS(
	in float2 coord0: TEXCOORD0,
	in float4 coord1: TEXCOORD1,
	in float4 coord2 : TEXCOORD2) : COLOR
{
#if GHOST_COLOR_SHIFT_ENABLE
	float4 screenPosition = mul(float4(LightPosition, 1), matViewProject);
	screenPosition.xyz /= screenPosition.w;
	
	float2 deltaScreenPos = -normalize(screenPosition.xyz).xy;
	deltaScreenPos *= GhostAllColorShift.y;
	deltaScreenPos *= lerp(GhostAllColorShift.z, GhostAllColorShift.w, saturate(coord2.w / 16));
	deltaScreenPos *= GhostShiftParams[int(coord2.w)];

	float3 color = ChromaticAberration(GhostMapSamp, coord0, deltaScreenPos, 16, coord1) * coord2.xyz;
#else
	float3 color = srgb2linear(tex2Dlod(GhostMapSamp, float4(coord0, 0, 0)).rgb) * coord2.xyz;
#endif

#if GHOST_MAP_TYPE == 0
	color *= saturate(normalize(LightPosition).y);
#endif
	color = linear2srgb(color);

	return float4(color, luminance(color) * 0.5);
}

float4 ShowScreenVS(
	in float4 position: POSITION,
	in float4 texcoord: TEXCOORD,
	out float4 oTexcoord : TEXCOORD0) : POSITION
{
	oTexcoord = texcoord;
	return position;
}

float4 ShowScreenPS(in float2 coord: TEXCOORD0) : COLOR
{
	return tex2Dlod(ScnSamp, float4(coord, 0, 0));
}

float4 ClearColor = 0.0;
float ClearDepth  = 1.0;

float Script : STANDARDSGLOBAL <
	string ScriptOutput = "color";
	string ScriptClass = "scene";
	string ScriptOrder = "postprocess";
> = 0.8;

technique OpticalLight<
	string Script = 
		"RenderColorTarget=ScnMap;"
		"RenderDepthStencilTarget=;"
		"ClearSetColor=ClearColor;"
		"ClearSetDepth=ClearDepth;"
		"Clear=Color;"
		"Clear=Depth;"
		"ScriptExternal=Color;"

		"RenderColorTarget=;"
		"Clear=Color;"
		"Clear=Depth;"
		"Pass=ShowScreen;"

		"Pass=GenLensflare;"

		"LoopByCount=GhostCount;"
		"LoopGetIndex=GhostIndex;"
		"Pass=GenGhostImage;"
		"LoopEnd=;"
;>{
	pass ShowScreen<string Script= "Draw=Buffer;";>{
		AlphaBlendEnable = false; AlphaTestEnable = false;
		ZEnable = False; ZWriteEnable = False;
		CULLMODE = NONE;
		VertexShader = compile vs_3_0 ShowScreenVS();
		PixelShader  = compile ps_3_0 ShowScreenPS();
	}
	pass GenLensflare<string Script= "Draw=Buffer;";>
	{
		AlphaBlendEnable = true; AlphaTestEnable = false;
		ZEnable = false; ZWriteEnable = false;
		SrcBlend = ONE; DestBlend = INVSRCALPHA;
		CULLMODE = NONE;
		VertexShader = compile vs_3_0 LensflareVS();
		PixelShader  = compile ps_3_0 LensflarePS();
	}
	pass GenGhostImage<string Script= "Draw=Buffer;";>
	{
		AlphaBlendEnable = true; AlphaTestEnable = false;
		ZEnable = false; ZWriteEnable = false;
		SrcBlend = ONE; DestBlend = INVSRCALPHA;
		CULLMODE = NONE;
		VertexShader = compile vs_3_0 GhostImageVS(GhostIndex);
		PixelShader  = compile ps_3_0 GhostImagePS();
	}
}