#define LUT_SIZE 256

float time : TIME<bool SyncInEditMode=true;>;

float2 ViewportSize : VIEWPORTPIXELSIZE;
static float2 ViewportOffset  = (float2(0.5,0.5) / ViewportSize);
static float2 ViewportOffset2 = (float2(1.0,1.0) / ViewportSize);
static float  ViewportAspect  = ViewportSize.x / ViewportSize.y;

texture ScnMap : RENDERCOLORTARGET <
	float2 ViewPortRatio = {1.0,1.0};
	string Format = "A2B10G10R10";
>;
sampler ScnSamp = sampler_state {
	texture = <ScnMap>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};

texture Spectrum1Map<string ResourceName = WAVE_1_MAP_FILE;>; 
sampler Spectrum1MapSamp = sampler_state
{
	texture = <Spectrum1Map>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};

texture Spectrum2Map<string ResourceName = WAVE_2_MAP_FILE;>; 
sampler Spectrum2MapSamp = sampler_state
{
	texture = <Spectrum2Map>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};

#if USE_CUSTOM_PARAMS
static float mWaveLines = min(8, waveLines);
static float mWaveBloom = waveBloom;
static float mWaveHeightLow = waveHeightLow;
static float mWaveHeightHigh = waveHeightHigh;
static float mWaveFade = waveFade;
static float mWaveSin = waveSin;
static float mWaveCos = waveCos;
static float mWaveWheel = waveWheel;
static float mWaveOffset = waveOffset;

static float2 mSize = size;
static float2 mTranslate = translate;

static float3 mWaveColorLow = waveColorLow;
static float3 mWaveColorHigh = waveColorHigh;
#else
float mPositionXP : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "PosX+";>;
float mPositionYP : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "PosY+";>;
float mPositionXM : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "PosX-";>;
float mPositionYM : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "PosY-";>;
float mSizeX : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "SizeW-";>;
float mSizeY : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "SizeH-";>;

float mColorLowH : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "ColorLowH+";>;
float mColorLowS : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "ColorLowS+";>;
float mColorLowP : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "ColorLowV+";>;
float mColorLowM : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "ColorLowV-";>;
float mColorHighH : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "ColorHighH+";>;
float mColorHighS : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "ColorHighS+";>;
float mColorHighP : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "ColorHighV+";>;
float mColorHighM : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "ColorHighV-";>;

float mWaveBloomP : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "WaveBloom+";>;
float mWaveBloomM : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "WaveBloom-";>;
float mWaveHeightLowP : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "WaveHeightLow+";>;
float mWaveHeightLowM : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "WaveHeightLow-";>;
float mWaveHeightHighP : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "WaveHeightHigh+";>;
float mWaveHeightHighM : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "WaveHeightHigh-";>;
float mWaveSinP : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "WaveSin+";>;
float mWaveSinM : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "WaveSin-";>;
float mWaveCosP : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "WaveCos+";>;
float mWaveCosM : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "WaveCos-";>;
float mWaveOffsetP : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "WaveOffset+";>;
float mWaveOffsetM : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "WaveOffset-";>;
float mWaveFadeP : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "WaveFade+";>;
float mWaveFadeM : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "WaveFade-";>;
float mWaveWheelP : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "WaveWheel+";>;
float mWaveWheelM : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "WaveWheel-";>;
float mWaveLinesM : CONTROLOBJECT<string name="WaveLinesController.pmx"; string item = "WaveLines-";>;

static float mWaveLines = lerp(8, 1, mWaveLinesM);
static float mWaveBloom = lerp(lerp(3, 6, mWaveBloomP), 1, mWaveBloomM);
static float mWaveHeightLow = lerp(lerp(5, 15, mWaveHeightLowP), 1, mWaveHeightLowM);
static float mWaveHeightHigh = lerp(lerp(5, 15, mWaveHeightHighP), 1, mWaveHeightHighM);
static float mWaveFade = lerp(lerp(2, 4, mWaveFadeP), 0.1, mWaveFadeM);
static float mWaveSin = lerp(lerp(10, 20, mWaveSinP), 1, mWaveSinM);
static float mWaveCos = lerp(lerp(2, 4, mWaveCosP), 1, mWaveCosM);
static float mWaveWheel = lerp(lerp(1, 2, mWaveWheelP), 0, mWaveWheelM);
static float mWaveOffset = lerp(lerp(0, 1, mWaveOffsetP), -1, mWaveOffsetM);

static float2 mSize = 1.0 - float2(mSizeX, mSizeY);
static float2 mTranslate = float2(mPositionXP, mPositionYP) - float2(mPositionXM, mPositionYM);

static float3 mWaveColorLow = float3(mColorLowH, mColorLowS, lerp(lerp(1, 2, mColorLowP), 0, mColorLowM));
static float3 mWaveColorHigh = float3(mColorHighH, mColorHighS, lerp(lerp(1, 2, mColorHighP), 0, mColorHighM));
#endif

float3 ACESFilmLinear(float3 x)
{
	const float A = 2.51f;
	const float B = 0.03f;
	const float C = 2.43f;
	const float D = 0.59f;
	const float E = 0.14f;
	return (x * (A * x + B)) / (x * (C * x + D) + E);
}

float2 GetFramesPerSecond(float time, float size = LUT_SIZE)
{
	float frame = time / 8.5 * (size - 1);

	float y = floor(frame / size);
	float x = frame - y * size;

	return float2(x, y) / size;
}

float3 rgb2hsv(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));

	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

float3 hsv2rgb(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}

void SoundSpectrumVS(
	in float4 Position : POSITION,
	in float4 Texcoord : TEXCOORD0,
	out float4 oTexcoord  : TEXCOORD0,
	out float4 oPosition  : POSITION)
{
	oTexcoord = Texcoord;
	oTexcoord.zw = Texcoord.xy * ViewportSize;
	oTexcoord.xy += ViewportOffset.xy;
	oPosition = Position;
}

float4 SoundSpectrumPS(in float2 coord : TEXCOORD0) : COLOR 
{
	float3 color = 0;
	float2 index = GetFramesPerSecond(time);

	float4 freqs1 = tex2Dlod(Spectrum1MapSamp, float4(index, 0, 0));
	float4 freqs2 = tex2Dlod(Spectrum2MapSamp, float4(index, 0, 0));

	float2 wave = smoothstep(mTranslate, mTranslate + mSize, coord) * 2 - 1;

	const float freqs[8] = { freqs1 * mWaveHeightLow, freqs2 * mWaveHeightHigh};

	[unroll(8)]
	for (int i = 0; i < mWaveLines; ++i) 
	{
		float freq = freqs[i];

		float2 p = wave + float2(0, mWaveOffset * i / mWaveLines);
		p.x += i * 0.05 + freq * 0.1 + time * mWaveWheel;
		p.y += sin(p.x * mWaveSin) * cos(p.x * mWaveCos) * freq * 0.2 * ((i + 1.0) / float(mWaveLines));

		float intensity = 0.01 / abs(p.y) * log(1.6 + freq);

#if USE_RGB_SPACE
		float3 blend = lerp(mWaveColorLow, mWaveColorHigh, i / (mWaveLines));
#else
		float3 blend = lerp(hsv2rgb(mWaveColorLow), hsv2rgb(mWaveColorHigh), i / (mWaveLines));
#endif
		color += intensity * blend * mWaveBloom / mWaveLines;
	}

	color = clamp(color, 0, 20);
	color = color * pow(saturate(1 - length(wave)), mWaveFade);
	color = pow(ACESFilmLinear(color), 1.0 / 2.2);

	float3 screen = tex2Dlod(ScnSamp, float4(coord, 0, 0)).xyz;
	return float4(screen + color, 1);
}

float Script : STANDARDSGLOBAL <
	string ScriptOutput = "color";
	string ScriptClass  = "scene";
	string ScriptOrder  = "postprocess";
> = 0.8;

const float4 ClearColor = float4(0,0,0,0);
const float ClearDepth  = 1.0;

technique MainTech<
	string Script = 
	"RenderColorTarget0=ScnMap;"
	"ClearSetColor=ClearColor;"
	"ClearSetDepth=ClearDepth;"
	"Clear=Color;"
	"Clear=Depth;"
	"ScriptExternal=Color;"

	"RenderColorTarget=;"
	"Pass=SoundSpectrum;"
;>{
	pass SoundSpectrum < string Script= "Draw=Buffer;"; > {
		AlphaBlendEnable = false; AlphaTestEnable = false;
		ZEnable = False; ZWriteEnable = False;
		VertexShader = compile vs_3_0 SoundSpectrumVS();
		PixelShader  = compile ps_3_0 SoundSpectrumPS();
	}
}