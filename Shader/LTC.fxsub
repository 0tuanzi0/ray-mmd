#define LUT_SIZE  64.0
#define LUT_SCALE (LUT_SIZE - 1.0)/LUT_SIZE
#define LUT_BIAS  0.5/LUT_SIZE

texture LTC1<string ResourceName = "../../../shader/textures/ltc_1.dds"; int Miplevels = 1;>;
sampler LTC1Samp = sampler_state {
	texture = <LTC1>;
	MINFILTER = LINEAR; MAGFILTER = LINEAR; MIPFILTER = NONE;
	ADDRESSU = CLAMP; ADDRESSV = CLAMP; SRGBTexture = TRUE;
};
texture LTC2<string ResourceName = "../../../shader/textures/ltc_2.dds"; int Miplevels = 1;>;
sampler LTC2Samp = sampler_state {
	texture = <LTC2>;
	MINFILTER = LINEAR; MAGFILTER = LINEAR; MIPFILTER = NONE;
	ADDRESSU = CLAMP; ADDRESSV = CLAMP; SRGBTexture = TRUE;
};

float3 IntegrateEdgeVec(float3 v1, float3 v2)
{
	float x = dot(v1, v2);
	float y = abs(x);

	float a = 0.8543985 + (0.4965155 + 0.0145206*y)*y;
	float b = 3.4175940 + (4.1616724 + y)*y;
	float v = a / b;

	float theta_sintheta = (x > 0.0) ? v : 0.5 * rsqrt(1.0 - x*x) - v;

	return cross(v1, v2)*theta_sintheta;
}

float IntegrateEdge(float3 v1, float3 v2)
{
	return IntegrateEdgeVec(v1, v2).z;
}

void ClipQuadToHorizon(inout float3 L[5], out int n)
{
	// detect clipping config
	int config = 0;
	if (L[0].z > 0.0) config += 1;
	if (L[1].z > 0.0) config += 2;
	if (L[2].z > 0.0) config += 4;
	if (L[3].z > 0.0) config += 8;

	// clip
	n = 0;

	if (config == 0)
	{
		// clip all
	}
	else if (config == 1) // V1 clip V2 V3 V4
	{
		n = 3;
		L[1] = -L[1].z * L[0] + L[0].z * L[1];
		L[2] = -L[3].z * L[0] + L[0].z * L[3];
	}
	else if (config == 2) // V2 clip V1 V3 V4
	{
		n = 3;
		L[0] = -L[0].z * L[1] + L[1].z * L[0];
		L[2] = -L[2].z * L[1] + L[1].z * L[2];
	}
	else if (config == 3) // V1 V2 clip V3 V4
	{
		n = 4;
		L[2] = -L[2].z * L[1] + L[1].z * L[2];
		L[3] = -L[3].z * L[0] + L[0].z * L[3];
	}
	else if (config == 4) // V3 clip V1 V2 V4
	{
		n = 3;
		L[0] = -L[3].z * L[2] + L[2].z * L[3];
		L[1] = -L[1].z * L[2] + L[2].z * L[1];
	}
	else if (config == 5) // V1 V3 clip V2 V4) impossible
	{
		n = 0;
	}
	else if (config == 6) // V2 V3 clip V1 V4
	{
		n = 4;
		L[0] = -L[0].z * L[1] + L[1].z * L[0];
		L[3] = -L[3].z * L[2] + L[2].z * L[3];
	}
	else if (config == 7) // V1 V2 V3 clip V4
	{
		n = 5;
		L[4] = -L[3].z * L[0] + L[0].z * L[3];
		L[3] = -L[3].z * L[2] + L[2].z * L[3];
	}
	else if (config == 8) // V4 clip V1 V2 V3
	{
		n = 3;
		L[0] = -L[0].z * L[3] + L[3].z * L[0];
		L[1] = -L[2].z * L[3] + L[3].z * L[2];
		L[2] =  L[3];
	}
	else if (config == 9) // V1 V4 clip V2 V3
	{
		n = 4;
		L[1] = -L[1].z * L[0] + L[0].z * L[1];
		L[2] = -L[2].z * L[3] + L[3].z * L[2];
	}
	else if (config == 10) // V2 V4 clip V1 V3) impossible
	{
		n = 0;
	}
	else if (config == 11) // V1 V2 V4 clip V3
	{
		n = 5;
		L[4] = L[3];
		L[3] = -L[2].z * L[3] + L[3].z * L[2];
		L[2] = -L[2].z * L[1] + L[1].z * L[2];
	}
	else if (config == 12) // V3 V4 clip V1 V2
	{
		n = 4;
		L[1] = -L[1].z * L[2] + L[2].z * L[1];
		L[0] = -L[0].z * L[3] + L[3].z * L[0];
	}
	else if (config == 13) // V1 V3 V4 clip V2
	{
		n = 5;
		L[4] = L[3];
		L[3] = L[2];
		L[2] = -L[1].z * L[2] + L[2].z * L[1];
		L[1] = -L[1].z * L[0] + L[0].z * L[1];
	}
	else if (config == 14) // V2 V3 V4 clip V1
	{
		n = 5;
		L[4] = -L[0].z * L[3] + L[3].z * L[0];
		L[0] = -L[0].z * L[1] + L[1].z * L[0];
	}
	else if (config == 15) // V1 V2 V3 V4
	{
		n = 4;
	}
	
	if (n == 3)
		L[3] = L[0];
	if (n == 4)
		L[4] = L[0];
}

float LTC_EvaluateRectangle(float3 N, float3 V, float3 P, float3 lightDirection, float3x3 invM, float3 points[4], bool twoSided)
{
	// construct orthonormal basis around N
	float3 T1, T2;
	T1 = normalize(V - N*dot(V, N));
	T2 = cross(N, T1);

	// rotate area light in (T1, T2, N) basis
	invM = mul(invM, float3x3(T1, T2, N));

	// polygon (allocate 5 vertices for clipping)
	float3 L[4];
	L[0] = mul(invM, points[0] - P);
	L[1] = mul(invM, points[1] - P);
	L[2] = mul(invM, points[2] - P);
	L[3] = mul(invM, points[3] - P);

	// integrate
   	float3 dir = points[0].xyz - P;
	bool behind = (dot(dir, -lightDirection) < 0.0);
	if (behind && !twoSided)
		return 0.0;

	L[0] = normalize(L[0]);
	L[1] = normalize(L[1]);
	L[2] = normalize(L[2]);
	L[3] = normalize(L[3]);

	float3 vsum = 0.0;
	vsum += IntegrateEdgeVec(L[0], L[1]);
	vsum += IntegrateEdgeVec(L[1], L[2]);
	vsum += IntegrateEdgeVec(L[2], L[3]);
	vsum += IntegrateEdgeVec(L[3], L[0]);

	float len = length(vsum);
	float z = vsum.z/len;

	if (behind)
		z = -z;

	float2 uv = float2(z * 0.5 + 0.5, len);
	uv = uv * LUT_SCALE + LUT_BIAS;

	float scale = tex2Dlod(LTC2Samp, float4(uv, 0, 0)).w;
	float sum = len * scale;

	return sum;
}

void LTC_InitRectPoints(float3 P, float3 Right, float3 Up, float LightWidth, float LightHeight, out float3 points[4])
{
	points[0] = P - Right * LightWidth - Up * LightHeight;
	points[1] = P - Right * LightWidth + Up * LightHeight;
	points[2] = P + Right * LightWidth + Up * LightHeight;
	points[3] = P + Right * LightWidth - Up * LightHeight;
}

float3 LTC_EvaluateRectangle(float3 N, float3 V, float3 P, float3 L, float3 points[4], float3 specular, float roughness, bool twoSided = false)
{
	float2 uv = float2(max(roughness, 0.01), sqrt(1.0 - saturate(dot(N, V))));
	uv = uv * LUT_SCALE + LUT_BIAS;

	float4 t1 = tex2Dlod(LTC1Samp, float4(uv, 0, 0));
	float4 t2 = tex2Dlod(LTC2Samp, float4(uv, 0, 0));

	float3x3 invM = float3x3(
		float3(t1.x, 0, t1.z),
		float3(  0,  1,    0),
		float3(t1.y, 0, t1.w)
	);

	float3 f0 = 0.04;
	float3 fresnel = f0 * t2.x + (1.0 - f0) * t2.y;

	return LTC_EvaluateRectangle(N, V, P, L, invM, points, twoSided) * fresnel;
}

float LTC_EvaluateRectangleDiffuse(float3 N, float3 V, float3 P, float3 L, float3 points[4], float roughness, bool twoSided = false)
{
	float3x3 invM = float3x3(
		float3(1, 0, 0),
		float3(0, 1, 0),
		float3(0, 0, 1)
	);

	return LTC_EvaluateRectangle(N, V, P, L, invM, points, twoSided);
}