bool ExistSkybox : CONTROLOBJECT<string name = "skybox.pmx";>;
bool ExistSkyboxHDR : CONTROLOBJECT<string name = "skybox_hdr.pmx";>;

float3 ShadingMaterial(float3 N, float3 V, float3 L, float2 coord, MaterialParam material)
{
    float3 lighting = 0;

#if MAIN_LIGHT_ENABLE
    float vis = saturate(dot(N, L));

#if SSSS_QUALITY > 0
    lighting = DiffuseBRDF(N, L, V, material);
    lighting *= (material.lightModel == LIGHTINGMODEL_TRANSMITTANCE) ? 1 : material.albedo;
#else
    lighting = material.albedo * DiffuseBRDF(N, L, V, material);
    lighting += SpecularBRDF(N, L, V, material.smoothness, material.specular) * vis;
#endif

    lighting *= LightSpecular * (mLightIntensityMin * (1 - mDirectionLightM) + mDirectionLightP * mLightIntensityMax);
    lighting *= step(0, material.albedo + material.specular - 1e-5);
    
#if SHADOW_QUALITY > 0
    lighting *= tex2D(ShadowmapSamp, coord).r;
#endif
#endif
    
    return lighting;
}

float3 ShadingImageBasedLighting(MaterialParam material, sampler source, float4 screenPosition, float2 coord, float3 N, float3 V, bool alpha)
{
    float3 lighting = 0;
    
#if IBL_QUALITY > 0   
    float3 diffuse, specular;
    
#if IBL_QUALITY > 1
    DecodeYcbcrWithEdgeFilter(source, coord, screenPosition, ViewportOffset2, diffuse, specular);
#else
    DecodeYcbcrBilinearFilter(source, coord, screenPosition, ViewportOffset2, diffuse, specular);
#endif

#if SSAO_SAMPLER_COUNT > 0
    float ssao = tex2D(SSAOMapSamp, coord).r;
    diffuse *= ssao;
    specular *= ComputeSpecularOcclusion(abs(dot(N, V)) + EPSILON, ssao, material.smoothness);
#endif

#if SSSS_QUALITY > 0
    diffuse *= (!alpha && material.lightModel == LIGHTINGMODEL_TRANSMITTANCE) ? 1 : material.albedo;
#else
    diffuse *= material.albedo;
#endif

    float shadow = 1;
#if MAIN_LIGHT_ENABLE && SHADOW_QUALITY > 0
    float2 shadowDepth = tex2D(ShadowmapSamp, coord).rg;
    shadow = lerp(1, shadowDepth.r, mEnvShadowP);
#endif

#if SSSS_QUALITY > 0
    lighting += (ExistSkybox || ExistSkyboxHDR) ? diffuse * shadow : 0;
#else
    lighting += (ExistSkybox || ExistSkyboxHDR) ? (diffuse + specular) * shadow : 0;
#endif
#endif

    return lighting;
}

float4 ShadingOpacityPS(
    in float2 coord: TEXCOORD0, 
    in float3 viewdir: TEXCOORD1, 
    in float4 screenPosition : SV_Position) : COLOR
{
    float4 MRT1 = tex2D(Gbuffer1Map, coord);
    float4 MRT2 = tex2D(Gbuffer2Map, coord);
    float4 MRT3 = tex2D(Gbuffer3Map, coord);
    float4 MRT4 = tex2D(Gbuffer4Map, coord);

    MaterialParam material;
    DecodeGbuffer(MRT1, MRT2, MRT3, MRT4, material);
            
    float3 N = material.normal;
    float3 V = normalize(viewdir);
    float3 L = mul(normalize(-LightDirection), (float3x3)matView);
    
    float3 lighting = ShadingMaterial(N, V, L, coord, material);
    lighting += tex2D(LightMapSamp, coord).rgb;
    lighting += srgb2linear(tex2D(ScnSamp, coord).rgb);
    lighting += ShadingImageBasedLighting(material, EnvLightMapSamp, screenPosition, coord, N, V, 0);

    return float4(lighting, material.linearDepth);
}

float4 ShadingOpacitySpecularPS(
    in float2 coord: TEXCOORD0, 
    in float3 viewdir: TEXCOORD1, 
    in float4 screenPosition : SV_Position) : COLOR
{
    float4 MRT1 = tex2D(Gbuffer1Map, coord);
    float4 MRT2 = tex2D(Gbuffer2Map, coord);
    float4 MRT3 = tex2D(Gbuffer3Map, coord);
    float4 MRT4 = tex2D(Gbuffer4Map, coord);

    MaterialParam material;
    DecodeGbuffer(MRT1, MRT2, MRT3, MRT4, material);
            
    float3 V = mul(normalize(viewdir), (float3x3)matViewInverse);
    float3 P = mul(float4(-viewdir * material.linearDepth, 1), matViewInverse).xyz;
    float3 N = mul(material.normal, (float3x3)matViewInverse);
    float3 L = normalize(-LightDirection);
    
    float3 specular = 0;
    
#if MAIN_LIGHT_ENABLE && SHADOW_QUALITY > 0
    specular = SpecularBRDF(N, L, V, material.smoothness, material.specular) * saturate(dot(N, L));
    specular *= LightSpecular * (mLightIntensityMin * (1 - mDirectionLightM) + mDirectionLightP * mLightIntensityMax);
    specular *= tex2D(ShadowmapSamp, coord).r;
#endif

    float3 iblDiffuse, iblSpecular;
    DecodeYcbcrBilinearFilter(EnvLightMapSamp, coord, screenPosition, ViewportOffset2, iblDiffuse, iblSpecular);
    
    specular += tex2D(LightMapSamp, coord).a;
    specular += iblSpecular;
    
#if FOG_ENABLE
    float4 fog = tex2D(FogMapSamp, coord);
    specular += fog.rgb;
#endif
    
    return float4(specular, 0);
}

float4 ShadingTransparentPS(
    in float2 coord: TEXCOORD0, 
    in float3 viewdir: TEXCOORD1, 
    in float4 screenPosition : SV_Position) : COLOR
{
    float4 MRT5 = tex2D(Gbuffer5Map, coord);
    float4 MRT6 = tex2D(Gbuffer6Map, coord);
    float4 MRT7 = tex2D(Gbuffer7Map, coord);
    float4 MRT8 = tex2D(Gbuffer8Map, coord);
    
    MaterialParam material;
    DecodeGbuffer(MRT5, MRT6, MRT7, MRT8, material);
        
    float3 N = material.normal;
    float3 V = normalize(viewdir);
    float3 L = mul(normalize(-LightDirection), (float3x3)matView);
    
    float3 lighting = ShadingMaterial(N, V, L, coord, material);
    lighting += tex2D(LightAlphaMapSamp, coord).rgb;
#if SSAO_SAMPLER_COUNT > 0
    float ssao = tex2D(SSAOMapSamp, coord).r;
    lighting *= ComputeSpecularOcclusion(abs(dot(N, V)) + EPSILON, ssao, material.smoothness);
#endif

    lighting += ShadingImageBasedLighting(material, EnvLightAlphaMapSamp, screenPosition, coord, N, V, 1);
        
    float ior = saturate(1 - material.specular.x / 0.04) * (1 - material.alpha) * material.alpha * 0.04325;
    float4 prefilteredRefract = tex2D(ShadingMapTempSamp, coord);
    lighting = lerp(prefilteredRefract.rgb, lighting, material.alpha);
    
    return float4(lighting, material.linearDepth);
}