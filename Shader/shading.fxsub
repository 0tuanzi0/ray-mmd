void ShadingMaterial(MaterialParam material, float3 N, float3 V, float3 L, float2 coord, out float3 diffuse, out float3 specular)
{
#if MAIN_LIGHT_ENABLE
	float4 energy = SurfaceEnergy(material, material.normal, L, L, V, 1.0);
	diffuse = energy.r + SubsurfaceShading(material, material.normal, L, V).rgb;
	specular = energy.gba;
	
#if SHADOW_QUALITY
	float shadow = tex2Dlod(ShadowmapSamp, float4(coord, 0, 0)).r;
	diffuse *= shadow;
	specular *= shadow;
#endif

	float3 lightColor = LightSpecular * mMainLightIntensity * step(0, sum(material.albedo + material.specular) - 1e-5);
	diffuse *= lightColor;
	specular *= lightColor;
	
#if SSAO_QUALITY > 3
	float3 bentNormal = tex2Dlod(SSAOMapSamp, float4(coord, 0, 0)).gba;
	float ssdo = pow(1 - saturate(dot(bentNormal * 2 - 1, L)), mSSDOScale);
	diffuse *= ssdo;
	specular *= ssdo;
#endif
#endif
}

void ShadingImageBasedLighting(sampler source, MaterialParam material, float4 screenPosition, float2 coord, float3 V, out float3 diffuse, out float3 specular)
{
#if IBL_QUALITY
	DecodeYcbcr(source, coord, screenPosition, ViewportOffset2, diffuse, specular);

#if SSAO_QUALITY
	float ssao = tex2Dlod(SSAOMapSamp, float4(coord, 0, 0)).r;
	diffuse *= ssao;
	specular *= ComputeSpecularOcclusion(abs(dot(material.normal, V)) + EPSILON, ssao, material.smoothness);
#endif

	float shadow = any(ExistSkybox + ExistSkyboxHDR);
#if MAIN_LIGHT_ENABLE && SHADOW_QUALITY
	float2 shadowDepth = tex2Dlod(ShadowmapSamp, float4(coord, 0, 0)).rg;
	shadow = lerp(shadow, shadowDepth.r, mEnvShadowP);
#endif

	diffuse *= material.visibility * shadow;
	specular *= material.visibility * shadow * shadow * shadow;
#endif
}

float4 ShadingOpacityPS(
	in float2 coord: TEXCOORD0, 
	in float3 viewdir: TEXCOORD1, 
	in float4 screenPosition : SV_Position) : COLOR
{
	float4 MRT1 = tex2Dlod(Gbuffer1Map, float4(coord, 0, 0));
	float4 MRT2 = tex2Dlod(Gbuffer2Map, float4(coord, 0, 0));
	float4 MRT3 = tex2Dlod(Gbuffer3Map, float4(coord, 0, 0));
	float4 MRT4 = tex2Dlod(Gbuffer4Map, float4(coord, 0, 0));

	MaterialParam material;
	DecodeGbuffer(MRT1, MRT2, MRT3, MRT4, material);

	float3 N = material.normal;
	float3 V = normalize(viewdir);
	float3 L = mul(normalize(-LightDirection), (float3x3)matView);
	
	float3 lighting = 0;
	lighting += tex2Dlod(LightMapSamp, float4(coord, 0, 0)).rgb;
	lighting += srgb2linear(tex2Dlod(ScnSamp, float4(coord, 0, 0)).rgb);

#if MAIN_LIGHT_ENABLE
	float3 diffuse, specular;
	ShadingMaterial(material, N, V, L, coord, diffuse, specular);
#if SSSS_QUALITY
	lighting += diffuse;
#else
	lighting += diffuse * material.albedo + specular;
#endif
#endif

#if IBL_QUALITY
	float3 iblDiffuse, iblSpecular;
	ShadingImageBasedLighting(EnvLightMapSamp, material, screenPosition, coord, V, iblDiffuse, iblSpecular);
#if SSSS_QUALITY
	lighting += iblDiffuse;
#else
	lighting += iblDiffuse * material.albedo + iblSpecular;
#endif
#endif
	
#if SSSS_QUALITY // Fix wihte edge
	float lightModel = DecodeLightModel(tex2Dlod(Gbuffer8Map, float4(coord, 0, 0)));
	material.linearDepth *= any(lightModel == SHADINGMODELID_SKIN || lightModel == SHADINGMODELID_SUBSURFACE);
#endif

	return float4(lighting, material.linearDepth);
}

float4 ShadingOpacityAlbedoPS(in float2 coord: TEXCOORD0) : COLOR
{
	float4 MRT1 = tex2Dlod(Gbuffer1Map, float4(coord, 0, 0));
	float4 MRT2 = tex2Dlod(Gbuffer2Map, float4(coord, 0, 0));
	float4 MRT3 = tex2Dlod(Gbuffer3Map, float4(coord, 0, 0));
	float4 MRT4 = tex2Dlod(Gbuffer4Map, float4(coord, 0, 0));

	MaterialParam material;
	DecodeGbuffer(MRT1, MRT2, MRT3, MRT4, material);
	
	clip(sum(material.albedo + material.specular) - 1e-5);
	
	return float4(material.albedo, 0);
}

float4 ShadingOpacitySpecularPS(
	in float2 coord: TEXCOORD0,
	in float3 viewdir: TEXCOORD1,
	in float4 screenPosition : SV_Position) : COLOR
{
	float4 MRT1 = tex2Dlod(Gbuffer1Map, float4(coord, 0, 0));
	float4 MRT2 = tex2Dlod(Gbuffer2Map, float4(coord, 0, 0));
	float4 MRT3 = tex2Dlod(Gbuffer3Map, float4(coord, 0, 0));
	float4 MRT4 = tex2Dlod(Gbuffer4Map, float4(coord, 0, 0));

	MaterialParam material;
	DecodeGbuffer(MRT1, MRT2, MRT3, MRT4, material);
			
	float3 N = material.normal;
	float3 V = normalize(viewdir);
	float3 L = mul(normalize(-LightDirection), (float3x3)matView);
	
	float3 lighting = 0;

#if MAIN_LIGHT_ENABLE
	float3 diffuse, specular;
	ShadingMaterial(material, N, V, L, coord, diffuse, specular);
	lighting += specular;
#endif

#if IBL_QUALITY
	float3 iblDiffuse, iblSpecular;
	ShadingImageBasedLighting(EnvLightMapSamp, material, screenPosition, coord, V, iblDiffuse, iblSpecular);
	lighting += iblSpecular;
#endif

	lighting += tex2Dlod(LightSpecMapSamp, float4(coord, 0, 0)).rgb;

	return float4(lighting, 0);
}

float4 ShadingTransparentPS(
	in float2 coord: TEXCOORD0, 
	in float3 viewdir: TEXCOORD1, 
	in float4 screenPosition : SV_Position) : COLOR
{
	float4 MRT5 = tex2Dlod(Gbuffer5Map, float4(coord, 0, 0));
	float4 MRT6 = tex2Dlod(Gbuffer6Map, float4(coord, 0, 0));
	float4 MRT7 = tex2Dlod(Gbuffer7Map, float4(coord, 0, 0));
	float4 MRT8 = tex2Dlod(Gbuffer8Map, float4(coord, 0, 0));
	
	MaterialParam material;
	DecodeGbuffer(MRT5, MRT6, MRT7, MRT8, material);

	float3 N = material.normal;
	float3 V = normalize(viewdir);
	float3 L = mul(normalize(-LightDirection), (float3x3)matView);
	
	float3 lighting = tex2Dlod(LightAlphaMapSamp, float4(coord, 0, 0)).rgb;

#if MAIN_LIGHT_ENABLE
	float3 diffuse, specular;
	ShadingMaterial(material, N, V, L, coord, diffuse, specular);
	lighting += diffuse * material.albedo + specular;
#endif

#if IBL_QUALITY
	float3 iblDiffuse, iblSpecular;
	ShadingImageBasedLighting(EnvLightAlphaMapSamp, material, screenPosition, coord, V, iblDiffuse, iblSpecular);
	lighting += iblDiffuse * material.albedo + iblSpecular;
#endif

	if (material.lightModel == SHADINGMODELID_GLASS)
	{
		float2 ior = mul(material.normal, (float3x3)matViewInverse).xy * material.customDataA * 0.04;
		float3 fresnel = lerp(material.specular, 1.0, pow5(1 - saturate(dot(N, V))) / (40 - 39 * material.smoothness));
		float3 prefilteredRefract = tex2Dlod(ShadingMapTempSamp, float4(coord + ior, 0, 0)).rgb;
		lighting = lerp(prefilteredRefract * material.customDataB, lighting, fresnel * material.alpha);
	}
	else
	{
		float3 prefilteredRefract = tex2Dlod(ShadingMapTempSamp, float4(coord, 0, 0)).rgb;
		lighting = lerp(prefilteredRefract, lighting, material.alpha);
	}

#if FOG_ENABLE
	float4 fog = tex2Dlod(FogMapSamp, float4(coord, 0, 0));
	lighting += fog.rgb;
#endif

	return float4(lighting, material.linearDepth);
}