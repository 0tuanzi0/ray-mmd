float3 ShadingMaterial(MaterialParam material, float3 N, float3 V, float3 L, float2 coord)
{
    float3 lighting = 0;

#if MAIN_LIGHT_ENABLE
    float vis = saturate(dot(N, L));

#if SSSS_QUALITY > 0
    lighting = SurfaceShading(material, N, L, V) + SubsurfaceShading(material, N, L, V);
#if SSSS_QUALITY > 1
    lighting *= (material.lightModel == SHADINGMODELID_SKIN) ? 1 : material.albedo;
#else
    lighting *= material.albedo;
#endif
#else
    lighting = material.albedo * SurfaceShading(material, N, L, V);
    lighting += SpecularBRDF(N, L, V, material.smoothness, material.specular) * vis;
#endif

    lighting *= LightSpecular * (mLightIntensityMin * (1 - mDirectionLightM) + mDirectionLightP * mLightIntensityMax);
    lighting *= step(0, material.albedo + material.specular - 1e-5);
    
#if SHADOW_QUALITY > 0
    lighting *= tex2Dlod(ShadowmapSamp, float4(coord, 0, 0)).r;
#endif
#endif
    
    return lighting;
}

float3 ShadingImageBasedLighting(MaterialParam material, sampler source, float4 screenPosition, float2 coord, float3 N, float3 V)
{
    float3 lighting = 0;
    
#if IBL_QUALITY > 0   
    float3 diffuse, specular;
    DecodeYcbcr(source, coord, screenPosition, ViewportOffset2, diffuse, specular);

#if SSAO_SAMPLER_COUNT > 0
    float ssao = tex2Dlod(SSAOMapSamp, float4(coord, 0, 0)).r;
    diffuse *= ssao;
    specular *= ComputeSpecularOcclusion(abs(dot(N, V)) + EPSILON, ssao, material.smoothness);
#endif

#if SSSS_QUALITY > 1
    diffuse *= (material.lightModel == SHADINGMODELID_SKIN) ? 1 : material.albedo;
#else
    diffuse *= material.albedo;
#endif

    float shadow = 1;
#if MAIN_LIGHT_ENABLE && SHADOW_QUALITY > 0
    float2 shadowDepth = tex2Dlod(ShadowmapSamp, float4(coord, 0, 0)).rg;
    shadow = lerp(1, shadowDepth.r, mEnvShadowP);
#endif

#if SSSS_QUALITY > 0
    lighting += diffuse * shadow;
#else
    lighting += (diffuse + specular) * shadow;
#endif
#endif

    return lighting;
}

float4 ShadingOpacityPS(
    in float2 coord: TEXCOORD0, 
    in float3 viewdir: TEXCOORD1, 
    in float4 screenPosition : SV_Position) : COLOR
{
    float4 MRT1 = tex2Dlod(Gbuffer1Map, float4(coord, 0, 0));
    float4 MRT2 = tex2Dlod(Gbuffer2Map, float4(coord, 0, 0));
    float4 MRT3 = tex2Dlod(Gbuffer3Map, float4(coord, 0, 0));
    float4 MRT4 = tex2Dlod(Gbuffer4Map, float4(coord, 0, 0));

    MaterialParam material;
    DecodeGbuffer(MRT1, MRT2, MRT3, MRT4, material);
            
    float3 N = material.normal;
    float3 V = normalize(viewdir);
    float3 L = mul(normalize(-LightDirection), (float3x3)matView);
    
    float3 lighting = ShadingMaterial(material, N, V, L, coord);
    lighting += tex2Dlod(LightMapSamp, float4(coord, 0, 0)).rgb;
    lighting += srgb2linear(tex2Dlod(ScnSamp, float4(coord, 0, 0)).rgb);
    lighting += ShadingImageBasedLighting(material, EnvLightMapSamp, screenPosition, coord, N, V);

    return float4(lighting, material.linearDepth);
}

float4 ShadingOpacitySpecularPS(
    in float2 coord: TEXCOORD0, 
    in float3 viewdir: TEXCOORD1, 
    in float4 screenPosition : SV_Position) : COLOR
{
    float4 MRT1 = tex2Dlod(Gbuffer1Map, float4(coord, 0, 0));
    float4 MRT2 = tex2Dlod(Gbuffer2Map, float4(coord, 0, 0));
    float4 MRT3 = tex2Dlod(Gbuffer3Map, float4(coord, 0, 0));
    float4 MRT4 = tex2Dlod(Gbuffer4Map, float4(coord, 0, 0));

    MaterialParam material;
    DecodeGbuffer(MRT1, MRT2, MRT3, MRT4, material);
            
    float3 V = mul(normalize(viewdir), (float3x3)matViewInverse);
    float3 P = mul(float4(-viewdir * material.linearDepth, 1), matViewInverse).xyz;
    float3 N = mul(material.normal, (float3x3)matViewInverse);
    float3 L = normalize(-LightDirection);
    
    float3 specular = 0;
    
#if MAIN_LIGHT_ENABLE && SHADOW_QUALITY > 0
    specular = SpecularBRDF(N, L, V, material.smoothness, material.specular) * saturate(dot(N, L));
    specular *= LightSpecular * (mLightIntensityMin * (1 - mDirectionLightM) + mDirectionLightP * mLightIntensityMax);
    specular *= tex2Dlod(ShadowmapSamp, float4(coord, 0, 0)).r;
#endif

    float3 iblDiffuse, iblSpecular;
    DecodeYcbcr(EnvLightMapSamp, coord, screenPosition, ViewportOffset2, iblDiffuse, iblSpecular);
    
    specular += tex2Dlod(LightMapSamp, float4(coord, 0, 0)).a;
    specular += iblSpecular;
       
    return float4(specular, 0);
}

float4 ShadingTransparentPS(
    in float2 coord: TEXCOORD0, 
    in float3 viewdir: TEXCOORD1, 
    in float4 screenPosition : SV_Position) : COLOR
{
    float4 MRT5 = tex2Dlod(Gbuffer5Map, float4(coord, 0, 0));
    float4 MRT6 = tex2Dlod(Gbuffer6Map, float4(coord, 0, 0));
    float4 MRT7 = tex2Dlod(Gbuffer7Map, float4(coord, 0, 0));
    float4 MRT8 = tex2Dlod(Gbuffer8Map, float4(coord, 0, 0));
    
    MaterialParam material;
    DecodeGbuffer(MRT5, MRT6, MRT7, MRT8, material);
        
    float3 N = material.normal;
    float3 V = normalize(viewdir);
    float3 L = mul(normalize(-LightDirection), (float3x3)matView);
    
    float3 lighting = ShadingMaterial(material, N, V, L, coord);
    lighting += tex2Dlod(LightAlphaMapSamp, float4(coord, 0, 0)).rgb;

#if SSAO_SAMPLER_COUNT > 0
    float ssao = tex2Dlod(SSAOMapSamp, float4(coord, 0, 0)).r;
    lighting *= ComputeSpecularOcclusion(abs(dot(N, V)) + EPSILON, ssao, material.smoothness);
#endif

    lighting += ShadingImageBasedLighting(material, EnvLightAlphaMapSamp, screenPosition, coord, N, V);
#if SSSS_QUALITY > 1
    lighting *= (material.lightModel == SHADINGMODELID_SKIN) ? material.albedo : 1;
#endif
    
    float ior = saturate(1 - material.specular.x / 0.04) * (1 - material.alpha) * material.alpha * 0.04325;
    float4 prefilteredRefract = tex2Dlod(ShadingMapTempSamp, float4(coord, 0, 0));
    lighting = lerp(prefilteredRefract.rgb, lighting, material.alpha);

#if FOG_ENABLE
    float4 fog = tex2Dlod(FogMapSamp, float4(coord, 0, 0));
    lighting += fog.rgb;
#endif
    
    return float4(lighting, material.linearDepth);
}