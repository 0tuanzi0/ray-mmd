float3 TonemapACES(float3 x)
{
	const float A = 2.51f;
	const float B = 0.03f;
	const float C = 2.43f;
	const float D = 0.59f;
	const float E = 0.14f;
	return (x * (A * x + B)) / (x * (C * x + D) + E);
}

float4 TonemapHable(float4 x) 
{
	float A = 0.22;
	float B = 0.30;
	float C = 0.10;
	float D = 0.20;
	float E = 0.01;
	float F = 0.30;
	return ((x*(A*x+C*B)+D*E) / (x*(A*x+B)+D*F)) - E / F;
}

float3 TonemapHejl2015(float3 hdr, float whitePt) 
{
	float4 vh = float4(hdr, whitePt);
	float4 va = 1.425 * vh + 0.05;
	float4 vf = (vh * va + 0.004) / (vh * (va + 0.55) + 0.0491) - 0.0821;
	return vf.rgb / vf.www;
}

float3 TonemapReinhardLumaBased(float3 color, float whitePt)
{
	float luma = luminance(color);
	float toneMappedLuma = luma * (1 + luma / (whitePt * whitePt))/ (1 + luma);
	color *= toneMappedLuma / luma;
	return color;
}

float3 ColorToneMapping(float3 color)
{
#if HDR_ENABLE && HDR_TONEMAP_OPERATOR == 1
	float3 curr = TonemapACES(color);
	return saturate(curr);
#elif HDR_ENABLE && HDR_TONEMAP_OPERATOR == 2
	float4 curr = TonemapHable(float4(pow(color * (1.0 / 0.18), 1.15) * 0.18, 4.0));
	curr = curr / curr.w;
	return saturate(curr);
#elif HDR_ENABLE && HDR_TONEMAP_OPERATOR == 3
	float3 curr = TonemapReinhardLumaBased(color, 4.0);
	return lerp(curr, color, mTonemapping);
#elif HDR_ENABLE && HDR_TONEMAP_OPERATOR == 4
	float4 curr = TonemapHable(float4(color, 8.0));
	curr = curr / curr.w;
	return saturate(curr);
#elif HDR_ENABLE && HDR_TONEMAP_OPERATOR == 5
	float3 curr = TonemapHejl2015(color, 8.0);
	return saturate(curr);
#else
	return saturate(color);
#endif
}

float3 noise3(float2 seed)
{
	return frac(sin(dot(seed.xy, float2(34.483, 89.637))) * float3(29156.4765, 38273.5639, 47843.7546));
}

float3 ColorBanding(float2 uv)
{
	float3 noise = noise3(uv) + noise3(uv + 0.5789) - 0.5;
	return noise / 255.0;
}

float4 ColorDithering(float3 color, float2 uv)
{
	color += ColorBanding(uv * (time + PI));
	return float4(color, 1);
}

float3 ColorVignette(float3 color, float2 coord)
{
	float L = length(coord * 2 - 1);
	return color * smoothstep(mVignetteOuter - mVignette * 2, mVignetteInner - mVignette, L);
}

float3 ColorTemperature(float3 color, float kelvin)
{
	float temp = kelvin / 100;
	float temp60 = max(0, temp - 60);
	float red = temp <= 66 ? 255 : 329.698727446 * pow(temp60, -0.1332047592);
	float green = temp <= 66 ? 99.4708025861 * log(temp) - 161.1195681661 : 288.1221695283 * pow(temp60, -0.0755148492);
	float blue = temp >= 66 ? 255 : (temp <= 19 ? 0 : 138.5177312231 * log(temp - 10) - 305.0447927307);
	float3 balance = saturate(float3(red, green, blue) / 255);
	return color * balance;
}

float3 ColorCorrect(
	float3 color, 
	float colorContrast, 
	float colorSaturation, 
	float colorGamma, 
	float3 colorGainP,
	float3 colorGainM)
{
	float3 lum = luminance(color);
	color = max(0, lerp(lum, color, colorSaturation));
	color = pow(color * (1.0 / 0.18), colorContrast) * 0.18;
	color = pow(color, colorGamma);
	color = color * (colorGainP + 1.0 - colorGainM);
	return color;
}

#if POST_DISPERSION_MODE == 2
float3 SampleSpectrum(float x)
{
	float t = 3.0 * x - 1.5;
	return saturate(float3(-t, 1 - abs(t), t));
}

float3 ChromaticAberration(sampler source, float2 coord, float2 offset)
{
	const int samples = 8;

	float3 totalColor = 0.0;
	float3 totalWeight = 0.0;
	float2 delta = offset / samples;

	[unroll]
	for (int i = 0; i <= samples; i++, coord += delta)
	{
		float3 w = SampleSpectrum(float(i) / samples);

		totalWeight += w;
		totalColor += w * tex2Dlod(source, float4(coord, 0, 0)).rgb;
	}

	return totalColor / totalWeight;
}
#endif

float3 ColorDispersion(sampler source, float2 coord, float inner, float outer)
{
#if POST_DISPERSION_MODE == 1
	float L = length(coord * 2 - 1);
	L = 1 - smoothstep(outer, inner, L);
	float2 offset = ViewportOffset2 * L * (mDispersion * 8) * BloomScale1;
	float3 shift1 = tex2Dlod(source, float4(coord - offset, 0, 0)).rgb;
	float3 shift2 = tex2Dlod(source, float4(coord, 0, 0)).rgb;
	float3 shift3 = tex2Dlod(source, float4(coord + offset, 0, 0)).rgb;
	return float3(shift1.r, shift2.g, shift3.b);
#elif POST_DISPERSION_MODE == 2
	float L = 1 - smoothstep(outer, inner, length(coord * 2 - 1));
	float2 dist = ViewportOffset2 * L * (mDispersion * 16) * BloomScale1;
	float2 offset = (coord * 2 - 1.0) * dist;
	return ChromaticAberration(source, coord, offset);
#else
	return tex2Dlod(source, float4(coord, 0, 0));
#endif
}

#if POST_COLORGRADING_MODE
void GenerateColorLUT_VS(
	in float4 Position : POSITION,
	in float4 Texcoord : TEXCOORD0,
	out float4 oTexcoord  : TEXCOORD0,
	out float4 oPosition  : POSITION)
{
	oTexcoord = Texcoord;
	oPosition = Position;
}

float4 GenerateColorLUT_PS(in float2 coord : TEXCOORD0) : COLOR 
{
	float3 color = CreateColorSpectrum(coord);

	color = ColorTemperature(color, mColorTemperature);
	color = ColorCorrect(color, mColorContrast, mColorSaturation, mColorGamma, mColorBalanceP, mColorBalanceM);
	color = ColorCorrectAll(
		color,
		mColorSaturationAll,
		mColorContrastAll,
		mColorGammaAll,
		mColorGainAll,
		mColorOffsetAll,

		mColorSaturationLow,
		mColorContrastLow,
		mColorGammaLow,
		mColorGainLow,
		mColorOffsetLow,

		mColorSaturationMid,
		mColorContrastMid,
		mColorGammaMid,
		mColorGainMid,
		mColorOffsetMid,

		mColorSaturationHigh,
		mColorContrastHigh,
		mColorGammaHigh,
		mColorGainHigh,
		mColorOffsetHigh,

		mColorCorrectionLowThreshold,
		mColorCorrectionHighThreshold);
	color = ColorToneMapping(color);

	return float4(linear2srgb(color), 0);
}
#endif

float4 HDRTonemappingPS(in float2 coord: TEXCOORD0, uniform sampler source) : COLOR
{
	float3 color = ColorDispersion(source, coord, mDispersionRadius, 1.0 + mDispersionRadius);

#if HDR_ENABLE && HDR_BLOOM_MODE > 0
	float3 bloom = tex2Dlod(GlareLightMapSamp, float4(coord, 0, 0)).rgb;
	color += bloom;
#endif

#if POST_COLORGRADING_MODE == 0
	color *= mExposure;

	color = ColorTemperature(color, mColorTemperature);
	color = ColorCorrect(color, mColorContrast, mColorSaturation, mColorGamma, mColorBalanceP, mColorBalanceM);
	color = ColorVignette(color, coord);
	color = ColorToneMapping(color);

	color = linear2srgb(color);
#else
	color = ColorVignette(color, coord);
	color = ColorLookupTable2D(ColorGradingLUTSamp, color * mExposure).rgb;

#if POST_COLORGRADING_MODE == 2
	color = CreateColorSpectrumDebug(color, ColorGradingLUTSamp, coord, ViewportAspect, mVisualizationLUT);
#endif
#endif

#if AA_QUALITY > 0
	return float4(color, luminance(color));
#else
	return ColorDithering(color, coord);
#endif
}