float SmoothnessToRoughness(float smoothness)
{
    return (1.0f - smoothness) * (1.0f - smoothness);
}

float RoughnessToSmoothness(float roughness)
{
    return 1.0f - sqrt(roughness);
}

float ShininessToSmoothness(float spec)
{
    return RoughnessToSmoothness(sqrt(2.0 / (spec + 2)));
}

float RoughnessToShininess(float roughness)
{
    return 2.0f / (roughness * roughness + 0.0001) - 2.0f;
}

float SmoothnessToShininess(float smoothness)
{
    float roughness = SmoothnessToRoughness(smoothness);
    return RoughnessToShininess(roughness);
}

float fresnelSchlick(float LdotH)
{
    return pow(1 - LdotH, 5);
}

float fresnelSchlick(float f0, float f9, float LdotH)
{
    return lerp(f0, f9, pow(1 - LdotH, 5));
}

float3 fresnelSchlick(float3 f0, float3 f9, float LdotH)
{
    return lerp(f0, f9, pow(1 - LdotH, 5));
}

float ComputeSpecularOcclusion(float nv, float ao, float smoothness)
{
    return saturate(pow(abs(nv + ao), smoothness) - 1 + ao);
}

float3 ComputeSpecularMicroOcclusion(float3 f0)
{
    return saturate(dot(f0, 0.33333h) * 50);
}

float ComputePhaseFunctions(float theta, float g)
{
    float gg = g * g;
    float g2 = 2 * g;
    
    float theta2 = theta * theta;
    float phase = ((1 - gg) /  pow(abs(1.0 + gg - g2 * theta2), 1.5));
    
    return phase;
}

float4 SubsurfaceShadingPreIntegratedSkin(MaterialParam material, float3 N, float3 L)
{
    float nl = dot(N, L) * 0.5 + 0.5;
    float curvature = material.customData;
    float curva = (1.0 / madd(curvature, 0.5 - 0.0625, 0.0625) - 2.0) / (16.0 - 2.0);
    float oneMinusCurva = 1.0 - curva;

    float3 rangeMin = float3(0.0, 0.3, 0.3);
    float3 rangeMax = float3(1.0, 0.7, 0.7);
    float3 offset = float3(0.0, 0.06, 0.06);
    float3 t = saturate(madd(nl, 1.0 / (rangeMax - rangeMin), (offset + rangeMin) / (rangeMin - rangeMax)));
    float3 lowerLine = (t * t) * float3(0.65, 0.5, 0.9);
    lowerLine.r += 0.045;
    lowerLine.b *= t.b;
    
    float3 m1 = float3(1.75, 2.0, 1.97);
    float3 m2 = float3(1.95, 2.0, 2.0);
    
    float3 lerpMin = float3(0.0, 0.35, 0.35);
    float3 lerpMax = float3(1.0, 0.7 , 0.6);
    float3 lerpT = saturate(madd(nl, 1.0 / (lerpMax - lerpMin), lerpMin / (lerpMin - lerpMax)));

    float3 upperLine1 = saturate(madd(nl, m1, float3(0.99, 0.99, 0.99) -m1));
    float3 upperLine2 = saturate(madd(nl, m2, float3(0.99, 0.99, 1.0) - m2));
    
    float3 curve1 = lerp(lowerLine, upperLine1, lerpT * lerpT);
    float3 curve2 = upperLine2;
    
    float oneMinusCurva2 = oneMinusCurva * oneMinusCurva;
    
    float3 brdf = lerp(curve1, curve2, madd(oneMinusCurva2, -1.0 * oneMinusCurva2, 1.0));
    
#if SSSS_QUALITY > 1
    return float4(material.transmittance * brdf, 0);
#else
    return float4(material.albedo * material.transmittance * brdf, 0);
#endif
}

float4 SubsurfaceShadingTwoSide(MaterialParam material, float3 N, float3 L, float3 V)
{
    float w = 0.5;
    float nl = saturate((dot(-N, L) + w) / pow2(1 + w));
    float phase = ComputePhaseFunctions(dot(V, L), 1 - material.customData);
    return float4(material.albedo * material.transmittance * nl * phase, 0);
}

float3 DiffuseBRDF(float3 N, float3 L, float3 V, MaterialParam material)
{
    float roughness = max(SmoothnessToRoughness(material.smoothness), 0.001);
    
    float3 H = normalize(V + L);
    
    float energyBias = 0.5 * roughness;
    float energyFactor = lerp(1, 1 / 1.51, roughness);

    float nl = saturate(dot(N, L));
    float vh = saturate(dot(V, H));
    float nv = max(abs(dot(N, V)), 0.1);

    float Fd90 = energyBias + 2.0 * vh * vh * roughness;

    float FL = fresnelSchlick(nl);
    float FV = fresnelSchlick(nv);
    
    float Fd = lerp(1, Fd90, FL) * lerp(1, Fd90, FV) * energyFactor;
    return Fd * nl;
}

float3 SpecularBRDF_GGX(float3 N, float3 L, float3 V, float roughness, float3 specular, float NormalizationFactor)
{
    float3 H = normalize(V + L);

    float nh = saturate(dot(N, H));
    float nl = saturate(dot(N, L));
    float vh = saturate(dot(V, H));
    float nv = abs(dot(N, V)) + 1e-5h;

    float m2 = roughness * roughness;
    float spec = (nh * m2 - nh) * nh + 1;
    spec = m2 / (spec * spec) * NormalizationFactor;

    float Gv = nl * sqrt((-nv * m2 + nv) * nv + m2);
    float Gl = nv * sqrt((-nl * m2 + nl) * nl + m2);
    spec *= 0.5h / (Gv + Gl);

    float3 f0 = max(0.02, specular);
    float3 f90 = ComputeSpecularMicroOcclusion(f0);
    float3 fresnel = fresnelSchlick(f0, f90, vh);

    return fresnel * spec * nl;
}

float3 SpecularBRDF_Cloth(float3 N, float3 L, float3 V, float roughness, float3 specular, float NormalizationFactor)
{
    float3 H = normalize(V + L);

    float nh = saturate(dot(N, H));
    float nl = saturate(dot(N, L));
    float vh = saturate(dot(V, H));
    float nv = saturate(dot(N, V));
    
    float m = roughness * roughness;
    float m2 = m * m;
    float A = 4;
    float spec = (nh - nh * m2) * nh + m2;
    spec /= (1 + A * m2) * (1 + 4 * m2 * m2 / (spec * spec)) * NormalizationFactor;
    
    float G = 4 * (nl + nv - nl * nv);
    spec /= G;
    
    float3 f0 = max(0.02, specular);
    float3 fresnel = fresnelSchlick(f0, 1, vh);
    
    return fresnel * spec * nl;
}

float4 SpecularBRDF_ClearCoat(float3 N, float3 L, float3 V, float roughness, float3 specular, float NormalizationFactor)
{
    float3 H = normalize(V + L);

    float nh = saturate(dot(N, H));
    float nl = saturate(dot(N, L));
    float vh = saturate(dot(V, H));
    
    float m2 = roughness * roughness;
    float spec = (nh * m2 - nh) * nh + 1;
    spec = m2 / (spec * spec) * NormalizationFactor;
    
    float G = (4 * vh * vh + 1e-5);
    spec /= G;
       
    float fresnel = fresnelSchlick(0.04, 1, vh);
    spec *= fresnel * nl;
    
    return float4(spec, spec, spec, 1 - fresnel);
}

float HorizonOcclusion(float3 N, float3 R)
{
    float factor = clamp(1.0 + 1.3 * dot(R, N), 0.1, 1.0);
    return factor * factor;
}

float EnvironmentMip(int miplevel, float smoothness)
{
    return lerp(miplevel, 0, smoothness * smoothness);
}

float3 EnvironmentReflect(float3 normal, float3 view)
{
    return reflect(-view, normal);
}

float3 EnvironmentSpecularUnreal4(float3 N, float3 V, float smoothness, float3 specular)
{
    float4 c0 = float4(-1, -0.0275, -0.572, 0.022);
    float4 c1 = float4(1, 0.0425, 1.04, -0.04);
    float4 r = SmoothnessToRoughness(smoothness) * c0 + c1;
    float a004 = min(r.x * r.x, exp2(-9.28 * dot(N, V))) * r.x + r.y;
    float2 AB = float2(-1.04, 1.04) * a004 + r.zw;
    return specular * AB.x + AB.y;
}

float EnvironmentSpecularUnreal4(float3 N, float3 V, float smoothness)
{
    const float2 c0 = float2(-1, -0.0275);
    const float2 c1 = float2(1, 0.0425);
    float2 r = SmoothnessToRoughness(smoothness) * c0 + c1;
    return min(r.x * r.x, exp2(-9.28 * dot(N, V))) * r.x + r.y;
}

float GetClosestBoundingBox(float intensity, float maxRadius)
{
    float E = 1e-2; //intensity / (maxRadius * maxRadius);
    return min(maxRadius, sqrt(intensity / E));
}

float GetPhysicalLightAttenuation(float3 L, float radius, float attenuationBulbSize)
{
    const float invRadius = 1 / radius;
    float d = length(L);
    float fadeoutFactor = saturate((radius - d) * (invRadius / 0.2h));
    d = max(d - attenuationBulbSize, 0);
    float denom = 1 + d / attenuationBulbSize;
    float attenuation = fadeoutFactor * fadeoutFactor / (denom * denom);
    return saturate(attenuation);
}

float GetPhysicalLightAttenuation(float3 L, float radius)
{
    return GetPhysicalLightAttenuation(L, radius, mLightAttenuationBlub);
}

float GetSpotLightAttenuation(float3 L, float3 lightDirection, float cosAngle, float scale)
{   
    float spotAngle = dot(L, -lightDirection);
    float lightAngleScale = 1.0f / max(0.001f, cosAngle);
    float lightAngleOffset = cosAngle * scale;
    float attenuation = saturate(spotAngle * lightAngleScale - lightAngleOffset);
    return attenuation;
}

float3 SphereLightDirection(float3 N, float3 V, float3 L, float lightRadius)
{
    float3 R = reflect(V, N);
    float3 centerToRay = dot(L, R) * R - L;
    float3 closestPoint = L + centerToRay * saturate(lightRadius / (length(centerToRay) + 1e-6));
    return normalize(closestPoint);
}

float SphereNormalization(float len, float radius, float gloss)
{
    float dist = saturate(radius / len);
    float normFactor = gloss / saturate(gloss + 0.5 * dist);
    return normFactor * normFactor;
}

float3 SphereAreaLightBRDF(float3 N, float3 V, float3 L, float radius, float gloss, float3 f0)
{
    float len = max(length(L),  1e-6);
    float3 L2 = SphereLightDirection(N, V, L, radius);
    float roughness = max(SmoothnessToRoughness(gloss), 0.001);
    return SpecularBRDF_GGX(N, V, L2, roughness, f0, SphereNormalization(len, radius, roughness));
}

float3 RectangleDirection(float3 L, float3 Lt, float3 Lb, float3 Ln, float2 Lwh, out float2 coord)
{
    float3 I = dot(Ln, L) * Ln - L;
    float2 lightPos2D = float2(dot(I, Lt), dot(I, Lb));
    float2 lightClamp2D = clamp(lightPos2D, -Lwh, Lwh);
    coord = saturate(lightClamp2D / Lwh * 0.5 + 0.5);
    return L + Lt * lightClamp2D.x + (Lb * lightClamp2D.y);
}

float3 RectangleLight(float3 R, float3 L, float3 Lt, float3 Lb, float3 Ln, float2 Lwh)
{
    float RdotN = dot(Ln, R) + 1e-6;
    float intersectLen = dot(Ln, L) / RdotN;
    float3 I = R * intersectLen - L;

    float2 lightPos2D = float2(dot(I, Lt), dot(I, Lb));
    float2 lightClamp2D = clamp(lightPos2D, -Lwh, Lwh);

    return L + Lt * lightClamp2D.x + Lb * lightClamp2D.y;
}

float3 RectangleLightWithUV(float3 R, float3 L, float3 Lt, float3 Lb, float3 Ln, float2 Lwh, out float2 coord)
{
    float RdotN = dot(Ln, R) + 1e-6;
    float intersectLen = dot(Ln, L) / RdotN;
    float3 I = R * intersectLen - L;

    float2 lightPos2D = float2(dot(I, Lt), dot(I, Lb));
    float2 lightClamp2D = clamp(lightPos2D, -Lwh, Lwh);
    coord = lightClamp2D / Lwh * 0.5 + 0.5;
    return L + Lt * lightClamp2D.x + Lb * lightClamp2D.y;
}

float RectangleAttenuation(float3 L, float3 lightDirection, float angle, float radius)
{
    float3 v = normalize(-L);
    float rectangleAngle = max(0, dot(v, lightDirection));   
    return rectangleAngle;
}

float3 RectangleLightBRDF(float3 N, float3 V, float3 L, float3 Lt, float3 Lb, float3 Ln, float2 Lwh, float gloss, float3 f0, out float2 coord)
{
    float3 R = reflect(V, N);
    float3 Lw = RectangleLightWithUV(R, L, Lt, Lb, Ln, Lwh, coord);
    float len = max(length(Lw), 1e-6);
    float3 L2 = Lw / len;
    float roughness = max(SmoothnessToRoughness(gloss), 0.001);
    return SpecularBRDF_GGX(N, L2, V, roughness, f0, SphereNormalization(len, Lwh.y, roughness));
}

float3 TubeLightDirection(float3 N, float3 V, float3 L0, float3 L1, float3 P, float radius)
{   
    float3 Ld = L1 - L0;
    float t = dot(-L0, Ld) / dot(Ld, Ld);
    float3 d = (L0 + Ld * saturate(t));
    return d - normalize(d) * radius;
}

float3 TubeLightSpecDirection(float3 N, float3 V, float3 L0, float3 L1, float3 P, float radius)
{      
    float3 Ld = L1 - L0;
    float3 R = reflect(V, N);
    
    float RoL0 = dot(R, L0);
    float RoLd = dot(R, Ld);
    float L0oLd = dot(L0, Ld);
    float T = (RoL0 * RoLd - L0oLd) / (dot(Ld, Ld) - RoLd * RoLd);
    
    float3 closestPoint = L0 + Ld * saturate(T);
    float3 centerToRay = dot(closestPoint, R) * R - closestPoint;
    
    return closestPoint + centerToRay * saturate(radius / length(centerToRay));
}

float3 TubeLightBRDF(float3 P, float3 N, float3 V, float3 L0, float3 L1, float LightWidth, float LightRadius, float smoothness, float3 f0)
{
    float3 Lw = TubeLightSpecDirection(N, V, L0, L1, P, LightRadius);
    
    float len = length(Lw);
    float3 L2 = Lw / len;
    
    float roughness = max(SmoothnessToRoughness(smoothness), 0.001);
    float normalizeFactor = SphereNormalization(len, length(float2(LightWidth, LightRadius)), roughness);
    return SpecularBRDF_GGX(N, L2, V, roughness, f0, normalizeFactor);
}

float4 StandardShading(MaterialParam material, float3 N, float3 L, float3 V, float normalizeFactor)
{
    float roughness = max(SmoothnessToRoughness(material.smoothness), 0.001);
    float3 specular = SpecularBRDF_GGX(N, L, V, roughness, material.specular, normalizeFactor);
    float3 diffuse = DiffuseBRDF(N, L, V, material);
    
#if SSSS_QUALITY > 1
    if (material.lightModel != SHADINGMODELID_SUBSURFACE &&
        material.lightModel != SHADINGMODELID_SKIN)
    {
        diffuse =  material.albedo;
    }
#else
    diffuse *= material.albedo;
#endif

#if SSSS_QUALITY > 1
    return float4(diffuse, luminance(specular));
#else
    return float4(diffuse + specular, 0);
#endif
}

float4 ClothShading(MaterialParam material, float3 N, float3 L, float3 V, float normalizeFactor)
{
    float roughness = max(SmoothnessToRoughness(material.smoothness), 0.001);
    
    float3 diffuse = DiffuseBRDF(N, L, V, material);
    float3 spec1 = SpecularBRDF_GGX(N, L, V, roughness, material.specular, normalizeFactor);
    float3 spec2 = SpecularBRDF_Cloth(N, L, V, roughness, material.specular, normalizeFactor);
    float3 cloth = lerp(spec1, spec2, material.customData);    
    return float4(material.albedo * diffuse + cloth, 0);
}

float4 ClearCoatShading(MaterialParam material, float3 N, float3 L, float3 V, float normalizeFactor)
{
    float roughness1 = max(SmoothnessToRoughness(material.smoothness), 0.001);
    float roughness2 = max(SmoothnessToRoughness(material.customData), 0.001);
    
    float3 diffuse = DiffuseBRDF(N, L, V, material);    
    float3 spec1 = SpecularBRDF_GGX(N, L, V, roughness1, material.specular, normalizeFactor);
    float4 spec2 = SpecularBRDF_ClearCoat(N, L, V, roughness2, material.specular, normalizeFactor);    
    return float4((material.albedo * diffuse + spec1) * spec2.a + spec2.rgb, 0);
}

float4 SurfaceShading(MaterialParam material, float3 N, float3 L, float3 V, float normalizeFactor)
{
    if (material.lightModel == SHADINGMODELID_CLOTH)
    {
        return ClothShading(material, N, L, V, normalizeFactor);
    }
    else if (material.lightModel == SHADINGMODELID_CLEAR_COAT)
    {
        return ClearCoatShading(material, N, L, V, normalizeFactor);
    }
    else
    {
        return StandardShading(material, N, L, V, normalizeFactor);
    }
}

float4 SubsurfaceShading(MaterialParam material, float3 N, float3 L, float3 V)
{
    if (material.lightModel == SHADINGMODELID_SKIN)
    {
        return SubsurfaceShadingPreIntegratedSkin(material, N, L);
    }
    else if (material.lightModel == SHADINGMODELID_SUBSURFACE)
    {
        return SubsurfaceShadingTwoSide(material, N, L, V);        
    }
    else
    {
        return 0;
    }
}