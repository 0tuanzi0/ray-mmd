struct LightParam
{
	float3 eye;

	float3 FogPosition;
	float3 FogColor;

	float FogRange;
	float FogDensity;
	float FogIntensity;
	float FogMiePhase;
	float FogAttenuationBulb;
};

float ComputeOpticalDepth(LightParam param, float depth)
{
	return exp(-depth * param.FogDensity);
}

float ComputeScatteringExtinction(LightParam param, float depth)
{
	return (1 - exp(-depth * param.FogDensity));
}

float GetPhysicalLightAttenuation(float3 L, float radius, float attenuationBulbSize)
{
	const float invRadius = 1 / radius;
	float d = length(L);
	float fadeoutFactor = saturate((radius - d) * (invRadius / 0.2h));
	d = max(d - attenuationBulbSize, 0);
	float denom = 1 + d / attenuationBulbSize;
	float attenuation = fadeoutFactor * fadeoutFactor / (denom * denom);
	return saturate(attenuation);
}

float ShadowTest(LightParam param, sampler shadowMap, float shadowSize, float3 viewPosition)
{
	float4 worldPosition = mul(float4(viewPosition, 1), matViewInverse);
	float3 L = worldPosition.xyz - param.FogPosition;

	float linearDepth = length(L);

	float depthScale = 85;
	float depth = (mPointLightFar / linearDepth) * (linearDepth - mPointLightNear) / (mPointLightFar - mPointLightNear);

	float2 coord = CalcDualShadowCoord(L / linearDepth, shadowSize);
	return tex2Dlod(shadowMap, float4(coord, 0, 0)).r < depth ? 0 : 1;
}

float4 SphereFog(LightParam param, float3 V, float distance)
{
	float3 viewPosition = V * distance / V.z;

	float3 FogPos = mul(float4(param.FogPosition, 1), matView).xyz;
	float3 L = viewPosition - FogPos;

	float b = dot(V, L);
	float c = dot(L, L);

	float iv = 1.0f / sqrt(c - b * b);

	float3 scatteringMie = iv * (atan((distance + b) * iv) - atan(b * iv));
	scatteringMie *= param.FogColor * param.FogIntensity;
	scatteringMie *= ComputePhaseMie(dot(-V, normalize(L)), param.FogMiePhase);

	return float4(scatteringMie, 0);
}

float4 SphereFog(LightParam param, float3 viewdir, float depth, int stepNum)
{
	float3 viewPosition = viewdir * depth / viewdir.z;

	float stepLength = distance(viewPosition, viewdir);
	float stepSize = stepLength / stepNum;

	float3 stepDir = (viewPosition - viewdir) / stepLength;
	float3 step = stepDir * stepSize;
	float3 stepStart = viewdir + step;

	float3 FogPos = mul(float4(param.FogPosition, 1), matView).xyz;

	float scatteringMie = 0;
	float stepDepth = stepSize;

	for (int i = 0; i < stepNum; i++)
	{
		float3 L = stepStart - FogPos;
		float atten = GetPhysicalLightAttenuation(L, param.FogRange, param.FogAttenuationBulb);
		atten *= ComputePhaseMie(dot(-viewdir, normalize(L)), param.FogMiePhase);
		atten *= ComputeScatteringExtinction(param, stepDepth);

		stepDepth += stepSize;
		stepStart += step;
		scatteringMie += atten;
	}

	float3 scattering = scatteringMie;
	scattering *= param.FogColor * param.FogIntensity;

	return float4(scattering, 0);
}

float4 SphereFog(LightParam param, sampler shadowMap, float shadowSize, float3 viewdir, float depth, int stepNum)
{
	float3 viewPosition = viewdir * depth / viewdir.z;

	float stepLength = distance(viewPosition, viewdir);
	float stepSize = stepLength / stepNum;

	float3 stepDir = (viewPosition - viewdir) / stepLength;
	float3 step = stepDir * stepSize;
	float3 stepStart = viewdir + step;

	float3 FogPos = mul(float4(param.FogPosition, 1), matView).xyz;

	float scatteringMie = 0;
	float stepDepth = stepSize;

	for (int i = 0; i < stepNum; i++)
	{
		float3 L = stepStart - FogPos;
		float atten = GetPhysicalLightAttenuation(L, param.FogRange, param.FogAttenuationBulb);
		atten *= ComputePhaseMie(dot(-viewdir, normalize(L)), param.FogMiePhase);
		atten *= ComputeScatteringExtinction(param, stepDepth);
		atten *= ShadowTest(param, shadowMap, shadowSize, stepStart);

		stepDepth += stepSize;
		stepStart += step;
		scatteringMie += atten;
	}

	float3 scattering = scatteringMie;
	scattering *= param.FogColor * param.FogIntensity;

	return float4(scattering, 0);
}