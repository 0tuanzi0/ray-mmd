#if SHADOW_QUALITY == 1
#   define SHADOW_MAP_SIZE 1024
#elif SHADOW_QUALITY == 2
#   define SHADOW_MAP_SIZE 2048
#elif SHADOW_QUALITY == 3
#   define SHADOW_MAP_SIZE 4096
#elif SHADOW_QUALITY == 4
#   define SHADOW_MAP_SIZE 8192
#elif SHADOW_QUALITY == 5
#   define SHADOW_MAP_SIZE 16384
#endif

texture2D DepthBuffer : RENDERDEPTHSTENCILTARGET <
    float2 ViewPortRatio = {1.0,1.0};
    int MipLevels = 1;
    bool AntiAlias = false;
    string Format = "D24S8";
>;
texture2D ScnMap : RENDERCOLORTARGET <
    float2 ViewPortRatio = {1.0,1.0};
    int MipLevels = 1;
    bool AntiAlias = false;
    string Format = "A16B16G16R16F";
>;
sampler ScnSamp = sampler_state {
    texture = <ScnMap>;
    MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP;  AddressV = CLAMP;
};
shared texture MaterialMap: OFFSCREENRENDERTARGET <
    string Description = "Material cache map for ray";
    float2 ViewPortRatio = {1.0, 1.0};
    float4 ClearColor = { 0, 0, 0, 0 };
    float ClearDepth = 1.0;
    string Format = "A8R8G8B8";
    int Miplevels = 1;
    bool AntiAlias = false;
    string DefaultEffect =
        "self = hide;"
        "*fog.pmx=hide;"
        "*controller.pmx=hide;"
        "*.pmd = ./materials/material.fx;"
        "*.pmx = ./materials/material.fx;"
        "*.x = hide;"
        "* = hide;";
>;
#if IBL_QUALITY
texture EnvLightMap: OFFSCREENRENDERTARGET <
    string Description = "Image-based-lighting map for ray";
    float2 ViewPortRatio = {1.0, 1.0};
    string Format = "A16B16G16R16F";
    float4 ClearColor = { 0, 0.5, 0, 0.5 };
    float ClearDepth = 1.0;
    int Miplevels = 1;
    bool AntiAlias = false;
    string DefaultEffect =
        "skybox.pmx=./Skybox/skylighting_none.fx;"
        "skybox_hdr.pmx=./Skybox/skylighting_none.fx;"
        "*= hide;";
>;
shared texture EnvLightAlphaMap: RENDERCOLORTARGET <
    float2 ViewPortRatio = {1.0, 1.0};
    string Format = "A16B16G16R16F";
    int Miplevels = 1;
    bool AntiAlias = false;
>;
sampler EnvLightMapSamp = sampler_state {
    texture = <EnvLightMap>;
    MinFilter = NONE;   MagFilter = NONE;   MipFilter = NONE;
    AddressU  = CLAMP;  AddressV = CLAMP;
};
sampler EnvLightAlphaMapSamp = sampler_state {
    texture = <EnvLightAlphaMap>;
    MinFilter = NONE;   MagFilter = NONE;   MipFilter = NONE;
    AddressU  = CLAMP;  AddressV = CLAMP;
};
#endif
texture DepthMap : OFFSCREENRENDERTARGET <
    string Description = "SSAO and shadow rendering for ray";
    float2 ViewPortRatio = {1.0, 1.0};
    string Format = "A16B16G16R16F";
    float4 ClearColor = { 1, 0, 0, 0 };
    float ClearDepth = 1.0;
    int MipLevels = 1;
    string DefaultEffect =
        "self = hide;"
        "*fog.pmx=hide;"
        "*controller.pmx=hide;"
        "*.pmx=shadow/Depth.fx;"
        "*.pmd=shadow/Depth.fx;"
        "*.x=hide;";
>;
sampler DepthMapSamp = sampler_state {
    texture = <DepthMap>;
    MinFilter = NONE;   MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP;  AddressV = CLAMP;
};
shared texture Gbuffer2RT: RENDERCOLORTARGET <
    float2 ViewPortRatio = {1.0, 1.0};
    string Format = "A8R8G8B8" ;
    int Miplevels = 1;
    bool AntiAlias = false;
>;
shared texture Gbuffer3RT: RENDERCOLORTARGET <
    float2 ViewPortRatio = {1.0, 1.0};
    string Format = "A8R8G8B8";
    int Miplevels = 1;
    bool AntiAlias = false;
>;
shared texture Gbuffer4RT: RENDERCOLORTARGET <
    float2 ViewPortRatio = {1.0, 1.0};
    string Format = "A16B16G16R16F" ;
    bool AntiAlias = false;
    int MipLevels = 1;
>;
shared texture Gbuffer5RT: RENDERCOLORTARGET <
    float2 ViewPortRatio = {1.0, 1.0};
    string Format = "A8R8G8B8";
    int Miplevels = 1;
    bool AntiAlias = false;
>;
shared texture Gbuffer6RT: RENDERCOLORTARGET <
    float2 ViewPortRatio = {1.0, 1.0};
    string Format = "A8R8G8B8";
    int Miplevels = 1;
    bool AntiAlias = false;
>;
shared texture Gbuffer7RT: RENDERCOLORTARGET <
    float2 ViewPortRatio = {1.0, 1.0};
    string Format = "A8R8G8B8";
    int Miplevels = 1;
    bool AntiAlias = false;
>;
shared texture Gbuffer8RT: RENDERCOLORTARGET <
    float2 ViewPortRatio = {1.0, 1.0};
    string Format = "A16B16G16R16F";
    int Miplevels = 1;
    bool AntiAlias = false;
>;
sampler Gbuffer1Map = sampler_state {
    texture = <MaterialMap>;
    MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP; AddressV  = CLAMP;
};
sampler Gbuffer2Map = sampler_state {
    texture = <Gbuffer2RT>;
    MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP; AddressV  = CLAMP;
};
sampler Gbuffer3Map = sampler_state {
    texture = <Gbuffer3RT>;
    MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP;  AddressV = CLAMP;
};
sampler Gbuffer4Map = sampler_state {
    texture = <Gbuffer4RT>;
    MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP;  AddressV = CLAMP;
};
sampler Gbuffer5Map = sampler_state {
    texture = <Gbuffer5RT>;
    MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP;  AddressV = CLAMP;
};
sampler Gbuffer6Map = sampler_state {
    texture = <Gbuffer6RT>;
    MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP;  AddressV = CLAMP;
};
sampler Gbuffer7Map = sampler_state {
    texture = <Gbuffer7RT>;
    MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP;  AddressV = CLAMP;
};
sampler Gbuffer8Map = sampler_state {
    texture = <Gbuffer8RT>;
    MinFilter = NONE;   MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP;  AddressV = CLAMP;
};
texture2D ShadingMap : RENDERCOLORTARGET <
    float2 ViewPortRatio = {1.0, 1.0};
    string Format = "A16B16G16R16F";
    int Miplevels = 1;
    bool AntiAlias = false;
>;
texture2D ShadingMapTemp : RENDERCOLORTARGET <
    float2 ViewPortRatio = {1.0, 1.0};
    string Format = "A16B16G16R16F";
    int Miplevels = 1;
    bool AntiAlias = false;
>;
sampler ShadingMapSamp = sampler_state {
    texture = <ShadingMap>;
    MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = NONE;
    AddressU  = CLAMP;  AddressV = CLAMP;
};
sampler ShadingMapTempSamp = sampler_state {
    texture = <ShadingMapTemp>;
    MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = NONE;
    AddressU  = CLAMP;  AddressV = CLAMP;
};