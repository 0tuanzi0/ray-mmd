#if SSAO_QUALITY == 1
#   define SSAO_SAMPLER_COUNT 8
#   define SSAO_BLUR_RADIUS 8
#elif SSAO_QUALITY == 2
#   define SSAO_SAMPLER_COUNT 12
#   define SSAO_BLUR_RADIUS 8
#elif SSAO_QUALITY >= 3
#   define SSAO_SAMPLER_COUNT 16
#   define SSAO_BLUR_RADIUS 8
#else
#   define SSAO_SAMPLER_COUNT 8
#   define SSAO_BLUR_RADIUS 8
#endif

shared texture SSAOMap : RENDERCOLORTARGET <
    float2 ViewPortRatio = {1.0, 1.0};
    int Miplevels = 1;
    bool AntiAlias = false;
    string Format = "L8";
>;
texture SSAOMapTemp : RENDERCOLORTARGET <
    float2 ViewPortRatio = {1.0, 1.0};
    int Miplevels = 1;
    bool AntiAlias = false;
    string Format = "L8";
>;
sampler SSAOMapSamp = sampler_state {
    texture = <SSAOMap>;
    MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = NONE;
    AddressU  = CLAMP;  AddressV = CLAMP;
};
sampler SSAOMapSampTemp = sampler_state {
    texture = <SSAOMapTemp>;
    MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = NONE;
    AddressU  = CLAMP;  AddressV = CLAMP;
};

float linearizeDepth(float2 uv)
{
    return tex2Dlod(DepthMapSamp, float4(uv, 0, 0)).g;
}

float linearizeDepth2(float2 uv)
{
    return tex2Dlod(Gbuffer8Map, float4(uv, 0, 0)).r;
}

float3 GetPosition(float2 uv)
{
    float depth = abs(linearizeDepth(uv));
    return ReconstructPos(uv, matProjectInverse, depth);
}

float3 GetNormal(float2 uv)
{
    float4 MRT6 = tex2Dlod(Gbuffer6Map, float4(uv, 0, 0));
    return DecodeGBufferNormal(MRT6);
}

float2 tapLocation(int index, float noise)
{
    float alpha = PI_2 * 7 / SSAO_SAMPLER_COUNT;
    float angle = (index + noise) * alpha;
    float radius = (1 + mSSAORadiusM - mSSAORadiusP) * 16;
    float2 radiusStep = ((ViewportSize.x / radius) / ViewportSize) * ((0.5 + index) / SSAO_SAMPLER_COUNT);
    return float2(cos(angle), sin(angle)) * radiusStep;
}

float4 SSAO(in float4 coord : TEXCOORD0, in float3 viewdir : TEXCOORD1) : COLOR
{
    float depth = linearizeDepth(coord.xy);
    float3 viewNormal = GetNormal(coord.xy);
    float3 viewPosition = -viewdir * abs(depth);
       
    float sampleWeight = 0.0f;
    float sampleAmbient = 0.0f;
    float sampleNoise = GetJitterOffset(coord.zw);
    float sampleRadius2 = mSSAOSpaceRadius * mSSAOSpaceRadius * mLightAttenuationBlub;
    float sampleScale = saturate((mSSAOBiasFalloff * 0.5) / viewPosition.z);
    float sampleBias = viewPosition.z * mSSAOBiasFar + saturate(1 - viewPosition.z / mSSAOBiasFalloff) * mSSAOBiasNear;
    
    [unroll]
    for (int j = 0; j < SSAO_SAMPLER_COUNT; j += 4)
    {
        float2 sampleOffset[4];
        sampleOffset[0] = coord.xy + tapLocation(j, sampleNoise) * sampleScale;
        sampleOffset[1] = coord.xy + tapLocation(j + 1, sampleNoise) * sampleScale;
        sampleOffset[2] = coord.xy + tapLocation(j + 2, sampleNoise) * sampleScale;
        sampleOffset[3] = coord.xy + tapLocation(j + 3, sampleNoise) * sampleScale;
        
        float3 samplePosition[4];
        samplePosition[0] = GetPosition(sampleOffset[0]);
        samplePosition[1] = GetPosition(sampleOffset[1]);
        samplePosition[2] = GetPosition(sampleOffset[2]);
        samplePosition[3] = GetPosition(sampleOffset[3]);
        
        float3 sampleDirection[4];
        sampleDirection[0] = samplePosition[0] - viewPosition;
        sampleDirection[1] = samplePosition[1] - viewPosition;
        sampleDirection[2] = samplePosition[2] - viewPosition;
        sampleDirection[3] = samplePosition[3] - viewPosition;

        float4 sampleLength2 = float4(
            dot(sampleDirection[0], sampleDirection[0]),
            dot(sampleDirection[1], sampleDirection[1]),
            dot(sampleDirection[2], sampleDirection[2]),
            dot(sampleDirection[3], sampleDirection[3]));
               
        float4 sampleAngle = float4(
            dot(sampleDirection[0], viewNormal),
            dot(sampleDirection[1], viewNormal),
            dot(sampleDirection[2], viewNormal),
            dot(sampleDirection[3], viewNormal));
        
        float4 sampleLength = rsqrt(sampleLength2);
        
        float4 f = max(0.0, sampleRadius2 - sampleLength2);
        float4 falloff = f * f * f;
        float4 occlustion = max(0.0, falloff * (sampleAngle - sampleBias) * sampleLength);

        sampleWeight += sum(falloff);
        sampleAmbient += sum(occlustion);
    }

    sampleAmbient /= sampleWeight;
    sampleAmbient *= depth < 0.0 ? 0.25 : 1.0;
    
    float ao = saturate(1 - sampleAmbient);
    return pow(ao,  (mSSAOIntensityMin + ao) * (1 - mSSAOM) + ao * ao * mSSAOP * mSSAOIntensityMax);
}

float4 SSAOBlur(in float2 coord : TEXCOORD0, in float3 viewdir : TEXCOORD1, uniform sampler source, uniform float2 offset) : COLOR
{
    float center_d = linearizeDepth2(coord);

    float total_c = tex2Dlod(source, float4(coord, 0, 0)).r;
    float total_w = 1.0f;
    
    float2 offset1 = coord + offset;
    float2 offset2 = coord - offset;
    
    float3 normal = GetNormal(coord);
    
    float angle = pow2(saturate(dot(normal, normalize(viewdir))));
    float falloff = saturate(center_d / mSSAOBlurFalloff);
    float sharpness = lerp(mSSAOBlurSharpnessMax * angle, mSSAOBlurSharpnessMin, falloff);
    
    [unroll]
    for (int r = 1; r < SSAO_BLUR_RADIUS; r++)
    {
        float depth1 = linearizeDepth2(offset1);
        float depth2 = linearizeDepth2(offset2);
        
        float bilateralWeight1 = BilateralWeight(r, depth1, center_d, SSAO_BLUR_RADIUS, sharpness);
        float bilateralWeight2 = BilateralWeight(r, depth2, center_d, SSAO_BLUR_RADIUS, sharpness);

        bilateralWeight1 *= saturate(dot(GetNormal(offset1), normal));
        bilateralWeight2 *= saturate(dot(GetNormal(offset2), normal));

        total_c += tex2Dlod(source, float4(offset1, 0, 0)).r * bilateralWeight1;
        total_c += tex2Dlod(source, float4(offset2, 0, 0)).r * bilateralWeight2;
        
        total_w += bilateralWeight1;
        total_w += bilateralWeight2;
        
        offset1 += offset;
        offset2 -= offset;
    }

    return total_c / total_w;
}