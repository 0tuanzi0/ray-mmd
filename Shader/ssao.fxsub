#if SSAO_QUALITY == 1
#   define SSAO_SAMPLER_COUNT 8
#   define SSAO_BLUR_RADIUS 8
#elif SSAO_QUALITY == 2
#   define SSAO_SAMPLER_COUNT 12
#   define SSAO_BLUR_RADIUS 8
#elif SSAO_QUALITY >= 3
#   define SSAO_SAMPLER_COUNT 16
#   define SSAO_BLUR_RADIUS 8
#else
#   define SSAO_SAMPLER_COUNT 8
#   define SSAO_BLUR_RADIUS 8
#endif

shared texture SSAOMap : RENDERCOLORTARGET <
    float2 ViewPortRatio = {1.0, 1.0};
    int Miplevels = 1;
    bool AntiAlias = false;
#if SSAO_QUALITY > 3
    string Format = "A8R8G8B8";
#else
    string Format = "L8";
#endif
>;
texture SSAOMapTemp : RENDERCOLORTARGET <
    float2 ViewPortRatio = {1.0, 1.0};
    int Miplevels = 1;
    bool AntiAlias = false;
#if SSAO_QUALITY > 3
    string Format = "A8R8G8B8";
#else
    string Format = "L8";
#endif
>;
sampler SSAOMapSamp = sampler_state {
    texture = <SSAOMap>;
    MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = NONE;
    AddressU  = CLAMP;  AddressV = CLAMP;
};
sampler SSAOMapSampTemp = sampler_state {
    texture = <SSAOMapTemp>;
    MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = NONE;
    AddressU  = CLAMP;  AddressV = CLAMP;
};

float linearizeDepth(float2 uv)
{
    return tex2D(DepthMapSamp, uv).g;
}

float3 GetPosition(float2 uv)
{
    float depth = abs(linearizeDepth(uv));
    return ReconstructPos(uv, matProjectInverse, depth);
}

float3 GetNormal(float2 uv)
{
    float4 MRT6 = tex2D(Gbuffer6Map, uv);
    return DecodeGBufferNormal(MRT6);
}

float2 tapLocation(int index, float noise)
{
    float alpha = PI_2 * 7 / SSAO_SAMPLER_COUNT;
    float angle = (index + noise) * alpha;
    float radius = (1 + mSSAORadiusM - mSSAORadiusP) * 16;
    float2 radiusStep = ((ViewportSize.x / radius) / ViewportSize) * ((0.5 + index) / SSAO_SAMPLER_COUNT);
    return float2(cos(angle), sin(angle)) * radiusStep;
}

float4 SSAO(in float4 coord : TEXCOORD0, in float3 viewdir : TEXCOORD1) : COLOR
{
    float depth = linearizeDepth(coord.xy);
    float3 viewNormal = GetNormal(coord.xy);
    float3 viewPosition = -viewdir * depth;
       
    float sampleWeight = 0.0f;
    float4 sampleAmbient = 0.0f;
    float sampleNoise = GetJitterOffset2(coord.zw);
    float sampleRadius2 = mSSAOSpaceRadius * mSSAOSpaceRadius * mLightAttenuationBlub;
    float sampleScale = saturate((mSSAOBiasFalloff * 0.5) / viewPosition.z);
    float sampleBias = viewPosition.z * mSSAOBiasFar + saturate(1 - viewPosition.z / mSSAOBiasFalloff) * mSSAOBiasNear;
    
    [unroll]
    for (int j = 0; j < SSAO_SAMPLER_COUNT; j += 4)
    {
        float2 sampleOffset[4];
        sampleOffset[0] = coord.xy + tapLocation(j, sampleNoise) * sampleScale;
        sampleOffset[1] = coord.xy + tapLocation(j + 1, sampleNoise) * sampleScale;
        sampleOffset[2] = coord.xy + tapLocation(j + 2, sampleNoise) * sampleScale;
        sampleOffset[3] = coord.xy + tapLocation(j + 3, sampleNoise) * sampleScale;
        
        float3 samplePosition[4];
        samplePosition[0] = GetPosition(sampleOffset[0]);
        samplePosition[1] = GetPosition(sampleOffset[1]);
        samplePosition[2] = GetPosition(sampleOffset[2]);
        samplePosition[3] = GetPosition(sampleOffset[3]);
        
        float3 sampleDirection[4];
        sampleDirection[0] = samplePosition[0] - viewPosition;
        sampleDirection[1] = samplePosition[1] - viewPosition;
        sampleDirection[2] = samplePosition[2] - viewPosition;
        sampleDirection[3] = samplePosition[3] - viewPosition;

        float4 sampleLength2 = float4(
            dot(sampleDirection[0], sampleDirection[0]),
            dot(sampleDirection[1], sampleDirection[1]),
            dot(sampleDirection[2], sampleDirection[2]),
            dot(sampleDirection[3], sampleDirection[3]));
               
        float4 sampleAngle = float4(
            dot(sampleDirection[0], viewNormal),
            dot(sampleDirection[1], viewNormal),
            dot(sampleDirection[2], viewNormal),
            dot(sampleDirection[3], viewNormal));
        
        float4 sampleLength = rsqrt(sampleLength2);
        
        float4 f = max(0.0, sampleRadius2 - sampleLength2);       
        float4 falloff = f * f * f;
        float4 occlustion = max(0.0, falloff * (sampleAngle - sampleBias) * sampleLength);

        sampleWeight += dot(falloff, 1);
        
#if SSAO_QUALITY > 3
        sampleAmbient.rgb += occlustion[0] * (sampleDirection[0] * sampleLength[0]);
        sampleAmbient.rgb += occlustion[1] * (sampleDirection[1] * sampleLength[1]);
        sampleAmbient.rgb += occlustion[2] * (sampleDirection[2] * sampleLength[2]);
        sampleAmbient.rgb += occlustion[3] * (sampleDirection[3] * sampleLength[3]);
        sampleAmbient.a += dot(occlustion, 1);
#else
        sampleAmbient += dot(occlustion, 1);   
#endif
    }

    sampleAmbient /= sampleWeight;
    float ao = saturate(1 - sampleAmbient.a);
    ao = pow(ao,  (mSSAOIntensityMin + ao) * (1 - mSSAOM) + ao * ao * mSSAOP * mSSAOIntensityMax);

#if SSAO_QUALITY > 3   
    return float4(sampleAmbient.rgb, ao);
#else
    return ao;
#endif
}

float4 SSAOBlur(in float2 coord : TEXCOORD0, in float3 viewdir : TEXCOORD1, uniform sampler source, uniform float2 offset) : COLOR
{
    float center_d = abs(linearizeDepth(coord));

    float4 total_c = tex2D(source, coord);
    float total_w = 1.0f;
    
    float2 offset1 = coord + offset;
    float2 offset2 = coord - offset;
    
    float3 normal = GetNormal(coord);
    
    float angle = pow2(saturate(dot(normal, normalize(viewdir))));
    float falloff = saturate(center_d / mSSAOBlurFalloff);
    float sharpness = lerp(mSSAOBlurSharpnessMax * angle, mSSAOBlurSharpnessMin, falloff);
    
    [unroll]
    for (int r = 1; r < SSAO_BLUR_RADIUS; r++)
    {
        float depth1 = abs(linearizeDepth(offset1));
        float depth2 = abs(linearizeDepth(offset2));
        
        float3 normal1 = GetNormal(offset1);
        float3 normal2 = GetNormal(offset2);
        
        float bilateralWeight1 = BilateralWeight(r, depth1, center_d, SSAO_BLUR_RADIUS, sharpness);
        float bilateralWeight2 = BilateralWeight(r, depth2, center_d, SSAO_BLUR_RADIUS, sharpness);

        bilateralWeight1 *= saturate(dot(normal1, normal));
        bilateralWeight2 *= saturate(dot(normal2, normal));

        total_c += tex2D(source, offset1) * bilateralWeight1;
        total_c += tex2D(source, offset2) * bilateralWeight2;
        
        total_w += bilateralWeight1;
        total_w += bilateralWeight2;
        
        offset1 += offset;
        offset2 -= offset;
    }

    return total_c / total_w;
}