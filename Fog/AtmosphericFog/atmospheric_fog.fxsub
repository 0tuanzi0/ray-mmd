#include "../../ray.conf"
#include "../../ray_advanced.conf"
#include "../../shader/math.fxsub"
#include "../../shader/common.fxsub"
#include "../../shader/PhaseFunctions.fxsub"
#include "../../shader/gbuffer.fxsub"
#include "../../shader/gbuffer_sampler.fxsub"

float mFogMieHP :  CONTROLOBJECT<string name="(self)"; string item = "MieH+";>;
float mFogMieSP :  CONTROLOBJECT<string name="(self)"; string item = "MieS+";>;
float mFogMieVP :  CONTROLOBJECT<string name="(self)"; string item = "MieV+";>;
float mFogMieVM :  CONTROLOBJECT<string name="(self)"; string item = "MieV-";>;
float mFogMiePhaseP :  CONTROLOBJECT<string name="(self)"; string item = "MiePhase+";>;
float mFogMiePhaseM :  CONTROLOBJECT<string name="(self)"; string item = "MiePhase-";>;
float mFogMieTurbidityP :  CONTROLOBJECT<string name="(self)"; string item = "MieTurbidity+";>;
float mFogMieTurbidityM :  CONTROLOBJECT<string name="(self)"; string item = "MieTurbidity-";>;
float mFogRayleightHP :  CONTROLOBJECT<string name="(self)"; string item = "RayleighH+";>;
float mFogRayleightSP :  CONTROLOBJECT<string name="(self)"; string item = "RayleighS+";>;
float mFogRayleightVP :  CONTROLOBJECT<string name="(self)"; string item = "RayleighV+";>;
float mFogRayleightVM :  CONTROLOBJECT<string name="(self)"; string item = "RayleighV-";>;

float mFogRangeP : CONTROLOBJECT<string name="(self)"; string item = "Range+";>;
float mFogRangeM : CONTROLOBJECT<string name="(self)"; string item = "Range-";>;
float mFogDensityP : CONTROLOBJECT<string name="(self)"; string item = "Density+";>;
float mFogDensityM : CONTROLOBJECT<string name="(self)"; string item = "Density-";>;
float mFogIntensityP : CONTROLOBJECT<string name="(self)"; string item = "Intensity+";>;
float mFogIntensityM : CONTROLOBJECT<string name="(self)"; string item = "Intensity-";>;

float3 LightDirection : DIRECTION< string Object = "Light";>;

static float mFogMiePhase = lerp(lerp(FogMiePhaseParams.x, FogMiePhaseParams.z, mFogMiePhaseP), FogMiePhaseParams.y, mFogMiePhaseM);
static float mFogMieTurbidity = lerp(lerp(FogMieTurbidityParams.x, FogMieTurbidityParams.z, mFogMieTurbidityP), FogMieTurbidityParams.y, mFogMieTurbidityM);
static float mFogRange = lerp(lerp(FogRangeParams.x, FogRangeParams.z, mFogRangeP), FogRangeParams.y, mFogRangeM);
static float mFogDensity = lerp(lerp(FogDensityParams.x, FogDensityParams.z, mFogDensityP), FogDensityParams.y, mFogDensityM);
static float mFogIntensity = lerp(lerp(FogIntensityParams.x, FogIntensityParams.z, mFogIntensityP), FogIntensityParams.y, mFogIntensityM);

static float3 FogMieColor = hsv2rgb(float3(mFogMieHP, mFogMieSP, lerp(lerp(1, 10, mFogMieVP), 0, mFogMieVM)));
static float3 FogRayleightColor = hsv2rgb(float3(mFogRayleightHP, mFogRayleightSP, lerp(lerp(1, 10, mFogRayleightVP), 0, mFogRayleightVM)));

#if FOG_WITH_GODRAY
	texture DownsampleMap : RENDERCOLORTARGET<float2 ViewportRatio={0.5, 0.5}; string Format="A16B16G16R16F";>;
	sampler DownsampleSamp = sampler_state {
		texture = <DownsampleMap>;
		MinFilter = Linear; MagFilter = Linear; MipFilter = NONE;
		AddressU = BORDER; AddressV = BORDER; BorderColor = 0.0;
	};
#endif

struct ScatteringParams
{
	float sunSize;
	float sunRadiance;

	float mieG;
	float mieHeight;

	float rayleighHeight;

	float3 waveLambda;
	float3 waveLambdaMie;
	float3 waveLambdaRayleigh;
	
	float fogRange;
	float fogDensity;
};

float3 ComputeSkyFog(ScatteringParams setting, float distance, float3 V, float3 L)
{
	float3 sunUp = float3(0, 1, 0);
	float3 sunDirection = normalize(L);

	float zenithAngle = saturate(dot(V, sunUp));

	float3 inscatteringMie = setting.waveLambdaMie;
	float3 inscatteringRayleigh = setting.waveLambdaRayleigh;

	float cosTheta = dot(V, sunDirection);

	float3 betaMie = inscatteringMie * ComputePhaseMie(cosTheta, setting.mieG);
	float3 betaRayleigh = inscatteringRayleigh * ComputePhaseRayleigh(cosTheta);
	float3 betaScattering = (betaMie + betaRayleigh);

	float3 inscattering = betaScattering / (inscatteringMie + inscatteringRayleigh);

	float3 extinction = exp(-(inscatteringMie + inscatteringRayleigh) * distance * setting.fogDensity);
	extinction = pow(extinction, setting.fogRange);

	return max(0, inscattering * (1.0 - extinction));
}

void AtmosphericFogVS(
	in float4 Position : POSITION,
	in float2 Texcoord : TEXCOORD0,
	out float2 oTexcoord0 : TEXCOORD0,
	out float3 oTexcoord1 : TEXCOORD1,
	out float3 oTexcoord2 : TEXCOORD2,
	out float3 oTexcoord3 : TEXCOORD3,
	out float4 oPosition : POSITION)
{
	oPosition = float4(CoordToPos(Texcoord), 0, 1);
	oTexcoord0 = Texcoord + ViewportOffset;
	oTexcoord1 = -mul(Position, matProjectInverse).xyz;
	oTexcoord2 = ComputeWaveLengthMie(mWaveLength, FogMieColor, mFogMieTurbidity, 4);
	oTexcoord3 = ComputeWaveLengthRayleigh(mWaveLength) * FogRayleightColor;
}

float4 AtmosphericFogPS(
	in float2 coord : TEXCOORD0, 
	in float3 viewdir : TEXCOORD1,
	in float3 mieLambda : TEXCOORD2,
	in float3 rayleight : TEXCOORD3) : COLOR
{
	float4 MRT5 = tex2Dlod(Gbuffer5Map, float4(coord, 0, 0));
	float4 MRT6 = tex2Dlod(Gbuffer6Map, float4(coord, 0, 0));
	float4 MRT7 = tex2Dlod(Gbuffer7Map, float4(coord, 0, 0));
	float4 MRT8 = tex2Dlod(Gbuffer8Map, float4(coord, 0, 0));

	MaterialParam material;
	DecodeGbuffer(MRT5, MRT6, MRT7, MRT8, material);

	float3 V = normalize(viewdir);
	float3 L = mul(LightDirection, (float3x3)matView);

	ScatteringParams params;
	params.waveLambdaMie = mieLambda;
	params.waveLambdaRayleigh = rayleight;
	params.fogRange = mFogRange;
	params.fogDensity = mFogDensity;
	params.mieG = mFogMiePhase;

	float3 fogAmount = ComputeSkyFog(params, material.linearDepth, V, L) * mFogIntensity;

#if FOG_DISCARD_SKY
	fogAmount *= step(0, sum(material.albedo + material.specular) - 1e-5);
#endif

	return float4(fogAmount, 0);
}

#if FOG_WITH_GODRAY
void LightShaftVS(
	in float4 Position : POSITION,
	in float2 Texcoord : TEXCOORD0,
	out float2 oTexcoord : TEXCOORD0,
	out float4 oPosition : POSITION)
{
	oPosition = float4(CoordToPos(Texcoord), 0, 1);
	oTexcoord = Texcoord + ViewportOffset;
}

float4 LightShaftPS(in float2 coord : TEXCOORD0) : COLOR0
{
    float4 illuminationPosition = mul(float4(-LightDirection * 80000, 1), matViewProject);
    if (illuminationPosition.w < 0)
    {
    	return tex2Dlod(DownsampleSamp, float4(coord, 0, 0));
    }

    illuminationPosition /= illuminationPosition.w;
    illuminationPosition.xy = PosToCoord(illuminationPosition);

    float2 sampleCoord = coord;
    float4 sampleColor = float4(0, 0, 0, 0);
    float2 sampleDecay = float2(1.0, 0.96);
    float2 sampleDelta = (coord - illuminationPosition.xy) / FOG_WITH_GODRAY_SAMPLES * 0.9;

    for (int i = 0; i < FOG_WITH_GODRAY_SAMPLES; i++)
    {
        sampleColor += float4(tex2Dlod(DownsampleSamp, float4(sampleCoord, 0, 0)).rgb, 0) * sampleDecay.x;
        sampleCoord -= sampleDelta;
        sampleDecay.x *= sampleDecay.y;
    }

    sampleColor /= FOG_WITH_GODRAY_SAMPLES;
    return float4(sampleColor.rgb, 0);
}

#define OBJECT_TEC(name, mmdpass) \
	technique name<string MMDPass = mmdpass;\
	string Script =\
		"RenderColorTarget=DownsampleMap;"\
		"Pass=DrawFog;"\
		"RenderColorTarget=;"\
		"Pass=DrawGodray;"\
	;>{\
		pass DrawFog {\
			ZEnable = false; ZWriteEnable = false;\
			AlphaBlendEnable = false; AlphaTestEnable = FALSE;\
			VertexShader = compile vs_3_0 AtmosphericFogVS();\
			PixelShader  = compile ps_3_0 AtmosphericFogPS();\
		}\
		pass DrawGodray {\
			ZEnable = false; ZWriteEnable = false;\
			AlphaBlendEnable = true; AlphaTestEnable = FALSE;\
			SrcBlend = ONE; DestBlend = ONE;\
			VertexShader = compile vs_3_0 LightShaftVS();\
			PixelShader  = compile ps_3_0 LightShaftPS();\
		}\
	}
#else
#define OBJECT_TEC(name, mmdpass) \
	technique name<string MMDPass = mmdpass;\
	string Script =\
		"RenderColorTarget=;"\
		"Pass=DrawFog;"\
	;>{\
		pass DrawFog {\
			ZEnable = false; ZWriteEnable = false;\
			AlphaBlendEnable = true; AlphaTestEnable = FALSE;\
			SrcBlend = ONE; DestBlend = ONE;\
			VertexShader = compile vs_3_0 AtmosphericFogVS();\
			PixelShader  = compile ps_3_0 AtmosphericFogPS();\
		}\
	}
#endif

OBJECT_TEC(MainTec0, "object")
OBJECT_TEC(MainTecBS0, "object_ss")

technique EdgeTec<string MMDPass = "edge";> {}
technique ShadowTech<string MMDPass = "shadow";> {}
technique ZplotTec<string MMDPass = "zplot";> {}