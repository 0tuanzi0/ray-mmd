#include "../../ray.conf"
#include "../../ray_advanced.conf"
#include "../../shader/math.fxsub"
#include "../../shader/common.fxsub"
#include "../../shader/shadowcommon.fxsub"
#include "../../shader/gbuffer.fxsub"
#include "../../shader/gbuffer_sampler.fxsub"
#include "../../shader/PhaseFunctions.fxsub"

float mR : CONTROLOBJECT<string name="(self)"; string item="R+";>;
float mG : CONTROLOBJECT<string name="(self)"; string item="G+";>;
float mB : CONTROLOBJECT<string name="(self)"; string item="B+";>;
float mRangeP : CONTROLOBJECT<string name="(self)"; string item="Range+";>;
float mRangeM : CONTROLOBJECT<string name="(self)"; string item="Range-";>;
float mIntensityP : CONTROLOBJECT<string name="(self)"; string item="Intensity+";>;
float mIntensityM : CONTROLOBJECT<string name="(self)"; string item="Intensity-";>;
float mMiePhaseP : CONTROLOBJECT<string name="(self)"; string item="MiePhase+";>;
float mMiePhaseM : CONTROLOBJECT<string name="(self)"; string item="MiePhase-";>;
float mMieDensityP : CONTROLOBJECT<string name="(self)"; string item="Density+";>;
float mMieDensityM : CONTROLOBJECT<string name="(self)"; string item="Density-";>;
float mFrequencyP : CONTROLOBJECT<string name="(self)"; string item="Frequency+";>;
float mFrequencyM : CONTROLOBJECT<string name="(self)"; string item="Frequency-";>;
float mWidthP : CONTROLOBJECT<string name="(self)"; string item="Width+";>;
float mHeightP : CONTROLOBJECT<string name="(self)"; string item="Height+";>;
float mDepthP : CONTROLOBJECT<string name="(self)"; string item="Depth+";>;

float3 mPosition : CONTROLOBJECT<string name="(self)"; string item = "Position";>;

static const float FogWidth = lerp(FogRangeParams.x, FogRangeParams.z, mWidthP);
static const float FogDepth = lerp(FogRangeParams.x, FogRangeParams.z, mDepthP);
static const float FogHeight = lerp(FogHeightParams.x, FogHeightParams.z, mHeightP);
static const float FogFrequency = lerp(lerp(FogFreqParams.x, FogFreqParams.z, mFrequencyP), FogFreqParams.y, mFrequencyM);
static const float FogMiePhase  = lerp(lerp(FogMieParams.x, FogMieParams.z, mMiePhaseP), FogMieParams.y, mMiePhaseM);
static const float FogDensity = lerp(lerp(FogDensityParams.x, FogDensityParams.z, mMieDensityP), FogDensityParams.y, mMieDensityM);
static const float FogIntensity = lerp(lerp(FogIntensityParams.x, FogIntensityParams.z, mIntensityP), FogIntensityParams.y, mIntensityM);

static const float3 FogPosition = mPosition;
static const float3 FogColor = float3(mR, mG, mB) * FogIntensity;

struct FogParams
{
	float3 FogColor;
	float3 FogPosition;
	float3 FogRange;

	float FogDensity;
	float FogIntensity;
	float FogMiePhase;
	float FogFrequency;
};

void ComputeCubeMinMax(float3 d, float3 q, float3 size, out float3 tmin, out float3 tmax)
{
	const float3 aabb[2] = { q - size, q + size };

	float3 symbol = step(0, d);

	tmin.x = aabb[1-symbol[0]].x;
	tmin.y = aabb[1-symbol[1]].y;
	tmin.z = aabb[1-symbol[2]].z;

	tmax.x = aabb[symbol[0]].x;
	tmax.y = aabb[symbol[1]].y;
	tmax.z = aabb[symbol[2]].z;
}

float2 ComputeRayCubeIntersection(float3 p, float3 d, float3 q, float3 size, float3 tmin, float3 tmax)
{
	const float3 inv = 1.0 / (d + 1e-16);

	tmin = (tmin - p) * inv;
	tmax = (tmax - p) * inv;

	tmin.x = max(max(tmin.x, tmin.y), tmin.z);
	tmax.x = min(min(tmax.x, tmax.y), tmax.z);

	if (tmin.x > tmax.x)
		return -1;

	return float2(tmin.x, tmax.x);
}

float2 ComputeRayCubeIntersection(float3 p, float3 d, float3 q, float3 size)
{
	float3 tmin, tmax;
	ComputeCubeMinMax(d, q, size, tmin, tmax);
	return ComputeRayCubeIntersection(p, d, q, size, tmin, tmax);
}

float ComputeOpticalDepth(FogParams param, float depth)
{
	return exp(-depth * param.FogDensity);
}

float2 hash(float2 x, float time)
{
    const float2 k = float2( 0.3183099, 0.3678794 );
    x = x*k + k.yx;
    float h = frac(16.0 * k.x*frac( x.x*x.y*(x.x+x.y)));
    
    float a = 6.2831*h + time;
    return float2( cos(a), sin(a) );
}

float displacementSimple(float2 p, float time, float freq = 0.05)
{
    float2 i = floor(p * freq);
    float2 f = frac(p * freq);

    float2 u = f*f*f*(f*(f*6.0-15.0)+10.0);
    float2 du = 30.0*f*f*(f*(f-2.0)+1.0);
    
    float2 ga = hash(i + float2(0.0,0.0), time);
    float2 gb = hash(i + float2(1.0,0.0), time);
    float2 gc = hash(i + float2(0.0,1.0), time);
    float2 gd = hash(i + float2(1.0,1.0), time);
    
    float va = dot(ga, f - float2(0.0,0.0));
    float vb = dot(gb, f - float2(1.0,0.0));
    float vc = dot(gc, f - float2(0.0,1.0));
    float vd = dot(gd, f - float2(1.0,1.0));

    return va + u.x * (vb - va) + u.y * (vc - va) + u.x * u.y * (va - vb - vc + vd);
}

float4 VolumetricFog(FogParams param, float3 V, float3 L, float3 start, float3 end, float jitter, int stepNum = VOLUMETRIC_FOG_SAMPLES_LENGTH)
{
	float3 sampleStep = (end - start) / stepNum;
#if VOLUMETRIC_FOG_WITH_JITTER
	float3 sampleStart = start + sampleStep * jitter;
#else
	float3 sampleStart = start + sampleStep;
#endif

	float sampleLength = length(sampleStep);
	float sampleOpticalDepth = ComputeOpticalDepth(param, sampleLength);

	float scatteringMie = 0;
	float scatteringDepth = 1;
	float scatteringDensity = 0;

	float3 tmin, tmax;
	ComputeCubeMinMax(L, param.FogPosition, param.FogRange, tmin, tmax);

	for (int i = 0; i < stepNum; i++, sampleStart += sampleStep, scatteringDepth *= sampleOpticalDepth)
	{
		float height = displacementSimple(sampleStart.xz, time, param.FogFrequency) * param.FogRange.y + param.FogPosition.y;
		if (height > sampleStart.y)
		{
			float2 intersections = ComputeRayCubeIntersection(sampleStart, L, param.FogPosition, param.FogRange, tmin, tmax);
			float3 sampleLightPoint = sampleStart + L * intersections.y;

#if VOLUMETRIC_FOG_HEIGHT_ADJUST
			sampleLightPoint.y = displacementSimple(sampleLightPoint.xz, time, param.FogFrequency) * param.FogRange.y + param.FogPosition.y;
#endif

			float scattering = ComputeOpticalDepth(param, distance(sampleLightPoint, sampleStart));
			scattering *= sampleOpticalDepth;
			scattering *= scatteringDepth;
			scattering *= sampleLength;

			scatteringMie += scattering;
			scatteringDensity += sampleLength;
		}
	}

	float3 scattering = param.FogColor * scatteringMie;
	scattering *= param.FogIntensity;
#if VOLUMETRIC_FOG_ANISOTROPY
	scattering *= ComputePhaseMieHG(dot(V, L), param.FogMiePhase);
#endif

	return float4(scattering, scatteringDensity * param.FogDensity * param.FogIntensity);
}

void VolumetricCubeVS(
	in float4 Position : POSITION,
	in float3 Normal : NORMAL,
	out float4 oTexcoord : TEXCOORD0,
	out float4 oPosition  : POSITION)
{
	Position.xyz = (Position.xyz - FogPosition) * float3(FogWidth, FogHeight, FogDepth) + FogPosition;
	oTexcoord = oPosition = mul(Position, matViewProject);
	oTexcoord.xy = PosToCoord(oTexcoord.xy / oTexcoord.w) + ViewportOffset;
	oTexcoord.xy = oTexcoord.xy * oTexcoord.w;
}

float4 VolumetricCubePS(float4 texcoord : TEXCOORD0) : COLOR
{
	FogParams param;
	param.FogPosition = FogPosition;
	param.FogRange = float3(FogWidth, FogHeight, FogDepth);
	param.FogIntensity = FogIntensity;
	param.FogColor = FogColor;
	param.FogMiePhase = FogMiePhase;
	param.FogFrequency = FogFrequency;
	param.FogDensity = FogDensity * (FogRangeParams.z * FogRangeParams.z * 2) / dot(param.FogRange.xz, param.FogRange.xz);

	texcoord.xy /= texcoord.w;

	float3 V = mul(float4(CoordToPos(texcoord), 1, 1), matViewProjectInverse);

	float2 intersections = ComputeRayCubeIntersection(CameraPosition, V, param.FogPosition, param.FogRange);
	clip(intersections.y);

	float linearDepth = tex2Dlod(Gbuffer8Map, float4(texcoord.xy, 0, 0)).r;
	clip(linearDepth - intersections.x);

	float3 start = CameraPosition + V * max(0, intersections.x);
	float3 end = CameraPosition + V * min(linearDepth, intersections.y);

	return VolumetricFog(param, V, normalize(-SunDirection), start, end, PseudoRandom(texcoord * ViewportSize + time));
}

technique MainTechBS0<string MMDPass = "object_ss"
;>{
	pass DrawObject {
		ZEnable = false; ZWriteEnable = false;
		AlphaBlendEnable = TRUE; AlphaTestEnable = FALSE;
		SrcBlend = ONE; DestBlend = ONE;
		CullMode = CW;
		VertexShader = compile vs_3_0 VolumetricCubeVS();
		PixelShader = compile ps_3_0 VolumetricCubePS();
	}
}

technique DepthTech<string MMDPass = "object";>{}
technique EdgeTec<string MMDPass = "edge";>{}
technique ShadowTech<string MMDPass = "shadow";>{}
technique ZplotTec<string MMDPass = "zplot";>{}