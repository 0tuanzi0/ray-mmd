float time : TIME;//<bool SyncInEditMode=true;>;

float4x4 matView : VIEW;
float4x4 matViewProject : VIEWPROJECTION;

float3 CameraPosition  : POSITION  < string Object = "Camera"; >;

float4 MaterialDiffuse : DIFFUSE  < string Object = "Geometry"; >;

#define TEXTURE_FILTER ANISOTROPIC
#define TEXTURE_MIP_FILTER ANISOTROPIC
#define TEXTURE_ANISOTROPY_LEVEL 16

#define SHADINGMODELID_GLASS 4

#define MIDPOINT_8_BIT (127.0f / 255.0f)
#define MAX_FRACTIONAL_8_BIT (255.0f / 256.0f)
#define TWO_BITS_EXTRACTION_FACTOR (3.0f + MAX_FRACTIONAL_8_BIT)

shared texture Gbuffer2RT: RENDERCOLORTARGET;
shared texture Gbuffer3RT: RENDERCOLORTARGET;
shared texture Gbuffer4RT: RENDERCOLORTARGET;
shared texture Gbuffer5RT: RENDERCOLORTARGET;
shared texture Gbuffer6RT: RENDERCOLORTARGET;
shared texture Gbuffer7RT: RENDERCOLORTARGET;
shared texture Gbuffer8RT: RENDERCOLORTARGET;

#if WAVE_MAP_ENABLE
	texture WaveNormalMap<string ResourceName = WAVE_MAP_FILE;>; 
	sampler WaveNormalMapSamp = sampler_state
	{
		texture = WaveNormalMap;
		MAXANISOTROPY = TEXTURE_ANISOTROPY_LEVEL;
		MINFILTER = TEXTURE_FILTER; MAGFILTER = TEXTURE_FILTER; MIPFILTER = TEXTURE_MIP_FILTER;
		ADDRESSU = WRAP; ADDRESSV = WRAP;
	};
#endif

#if WAVE_NOISE_MAP_ENABLE
	texture WaveFlowNoiseMap<string ResourceName = WAVE_NOISE_MAP_FILE;>; 
	sampler WaveFlowNoiseMapSamp = sampler_state
	{
		texture = WaveFlowNoiseMap;
		MAXANISOTROPY = TEXTURE_ANISOTROPY_LEVEL;
		MINFILTER = LINEAR; MAGFILTER = LINEAR; MIPFILTER = LINEAR;
		ADDRESSU = CLAMP; ADDRESSV = CLAMP;
	};
#endif

#if WAVE_FLOW_MAP_ENABLE
	texture WaveFlowMap<string ResourceName = WAVE_FLOW_MAP_FILE;>; 
	sampler WaveFlowMapSamp = sampler_state
	{
		texture = WaveFlowMap;
		MAXANISOTROPY = TEXTURE_ANISOTROPY_LEVEL;
		MINFILTER = LINEAR; MAGFILTER = LINEAR; MIPFILTER = LINEAR;
		ADDRESSU = CLAMP; ADDRESSV = CLAMP;
	};
#endif

#if WAVE_FOAM_MAP_ENABLE
	texture WaveFoamMap<string ResourceName = WAVE_FOAM_MAP_FILE;>; 
	sampler WaveFoamMapSamp = sampler_state
	{
		texture = WaveFoamMap;
		MAXANISOTROPY = TEXTURE_ANISOTROPY_LEVEL;
		MINFILTER = TEXTURE_FILTER; MAGFILTER = TEXTURE_FILTER; MIPFILTER = TEXTURE_MIP_FILTER;
		ADDRESSU = WRAP; ADDRESSV = WRAP;
	};
#endif

#if WAVE_RIPPLE_MAP_ENABLE
	texture WaveRippleMap<string ResourceName = WAVE_RIPPLE_MAP_FILE;>; 
	sampler WaveRippleMapSamp = sampler_state
	{
		texture = WaveRippleMap;
		MAXANISOTROPY = TEXTURE_ANISOTROPY_LEVEL;
		MINFILTER = TEXTURE_FILTER; MAGFILTER = TEXTURE_FILTER; MIPFILTER = TEXTURE_MIP_FILTER;
		ADDRESSU = WRAP; ADDRESSV = WRAP;
	};
#endif

struct MaterialParam
{
	float3 normal;
	float3 albedo;
	float3 specular;
	float3 emissive;
	float emissiveIntensity;
	float smoothness;
	float alpha;
	float visibility;
	float customDataA;
	float3 customDataB;
	int lightModel;
};

struct GbufferParam
{
	float4 buffer1 : COLOR0;
	float4 buffer2 : COLOR1;
	float4 buffer3 : COLOR2;
	float4 buffer4 : COLOR3;
};

float3 EncodeNormal(float3 normal)
{
	float p = sqrt(-normal.z * 8 + 8);
	float2 enc = normal.xy / p + 0.5f;
	float2 enc255 = enc * 255;
	float2 residual = floor(frac(enc255) * 16);
	return float3(floor(enc255), residual.x * 16 + residual.y) / 255;
}

float3 rgb2ycbcr(float3 col)
{
	float3 encode;
	encode.x = dot(float3(0.299, 0.587, 0.114),   col.rgb);
	encode.y = dot(float3(-0.1687, -0.3312, 0.5), col.rgb);
	encode.z = dot(float3(0.5, -0.4186, -0.0813), col.rgb);
	return float3(encode.x, encode.y * MIDPOINT_8_BIT + MIDPOINT_8_BIT, encode.z * MIDPOINT_8_BIT + MIDPOINT_8_BIT);
}

float3 ComputeTangentBinormalNormal(float3 N, float3 viewdir, float2 coord, float3 tangentNormal)
{
	float3 dp1 = ddx(viewdir);
	float3 dp2 = ddy(viewdir);
	float2 duv1 = ddx(coord);
	float2 duv2 = ddy(coord);

	float3x3 M = float3x3(dp1, dp2, N);
	float2x3 I = float2x3(cross(M[1], M[2]), cross(M[2], M[0]));
	float3 T = mul(float2(duv1.x, duv2.x), I);
	float3 B = mul(float2(duv1.y, duv2.y), I);

	float scaleT = 1.0f / (dot(T, T) + 1e-6);
	float scaleB = 1.0f / (dot(B, B) + 1e-6);

	float3x3 tbnTransform;
	tbnTransform[0] = normalize(T * scaleT);
	tbnTransform[1] = normalize(B * scaleB);
	tbnTransform[2] = N;

	return normalize(mul(tangentNormal, tbnTransform));
}

GbufferParam EncodeGbuffer(MaterialParam material, float linearDepth)
{
	GbufferParam gbuffer;
	gbuffer.buffer1.xyz = material.albedo;
	gbuffer.buffer1.w = material.smoothness;

	material.normal = mul(material.normal, (float3x3)matView);
	material.normal = normalize(material.normal);

	gbuffer.buffer2.xyz = EncodeNormal(material.normal);
	gbuffer.buffer2.w = material.customDataA;

	gbuffer.buffer3.xyz = rgb2ycbcr(material.specular);
	gbuffer.buffer3.w = 0;

	material.customDataB = rgb2ycbcr(min(0.999, material.customDataB));
	gbuffer.buffer3.yz = material.customDataB.gb;
	gbuffer.buffer3.w = material.customDataB.r * MAX_FRACTIONAL_8_BIT;
	gbuffer.buffer3.w = gbuffer.buffer3.w / TWO_BITS_EXTRACTION_FACTOR;

	gbuffer.buffer4 = float4(linearDepth, material.emissiveIntensity, material.lightModel, material.alpha);    
	gbuffer.buffer4.y = floor(material.emissiveIntensity * 100.0) + saturate(material.visibility) - 1e-5;

	return gbuffer;
}

float2 GetParalaxOffset(sampler source, float2 coord, float3 V)
{
	const float gradientScale = 0.5 * 0.01;// * GradientScale;
	const float heightScale   = 0.5 * 0.01;// * HeightScale;

	float4 paralaxCoord = coord.xyxy * float4(0.25, 0.25, 1, 1);

	float4 height = tex2D(source, paralaxCoord.xy) * 2 - 1;
	height.xy = gradientScale * height.xy;
	height.w  = heightScale   * height.w;   
	float2 paralaxOffset = V.xy * height.w + height.xy;

	height = tex2D(source, paralaxCoord.zw + paralaxOffset) * 2 - 1;
	height.xy = gradientScale * height.xy;
	height.w  = heightScale   * height.w;

	paralaxOffset += V.xy * height.w + height.xy;

	return paralaxOffset;
}

float3 GetWaveNormal(float2 coord, float3 N, float3 V)
{
#if WAVE_MAP_ENABLE || WAVE_RIPPLE_MAP_ENABLE
	float2 translate = waveMapTranslate.xy * time * 0.05 + 3.14;

#if WAVE_NOISE_MAP_ENABLE
	float noise = tex2Dlod(WaveFlowNoiseMapSamp, float4(coord, 0, 0)).r;
	translate += noise * 0.5;
#endif

#if WAVE_FLOW_MAP_ENABLE
	float2 flow = tex2Dlod(WaveFlowMapSamp, float4(coord, 0, 0)).rg * 2 - 1;
	translate += flow;
#endif

  //half fDistScale = saturate(10.0/Wave0.w);
  //half3 WaterDeepColor = (vRefraction.xyz * fDistScale + (1 - fDistScale) * half3(0, 0.1, 0.125));  

	float3 bumpNormal = 0;

#if WAVE_MAP_ENABLE
	float4 wave = coord.xyxy * waveMapLoopNumLow.xyxy;
	wave.zw *= float2(2, 2) * waveMapLoopNumHigh;
	wave += translate.xyxy;

	float2 paralaxOffset = GetParalaxOffset(WaveNormalMapSamp, wave.xy, V);
	float4 paralaxCoord = wave.xyxy * float4(0.25, 0.25, 1, 1) + paralaxOffset.xyxy;

	bumpNormal.xy = (tex2D(WaveNormalMapSamp, wave.zw + paralaxOffset.xy).xy * 2 - 1) * waveMapScaleHigh;
	bumpNormal += tex2D(WaveNormalMapSamp, paralaxCoord.xy).xyz * 2 - 1;
	bumpNormal += tex2D(WaveNormalMapSamp, paralaxCoord.zw).xyz * 2 - 1;
	bumpNormal.xy *= waveMapScaleLow;
#endif

#if WAVE_RIPPLE_MAP_ENABLE
	float4 ripple = coord.xyxy * rippleMapLoopNumLow.xyxy;
	bumpNormal.xy += tex2D(WaveRippleMapSamp, ripple.xy).xy * 5;
#endif

	return ComputeTangentBinormalNormal(N, V, coord, bumpNormal);
#else
	return N;
#endif
}

void MaterialVS(
	in float4 Position : POSITION, 
	in float3 Normal : NORMAL, 
	in float4 Texcoord: TEXCOORD0,
	out float3 oNormal   : TEXCOORD0,
	out float4 oTexcoord0 : TEXCOORD1,
	out float4 oTexcoord1 : TEXCOORD2,
	out float4 oTexcoord2 : TEXCOORD3,
	out float4 oPosition : POSITION)
{
	oNormal = Normal;
	oPosition = mul(Position, matViewProject);

	oTexcoord0 = Texcoord;
	oTexcoord1 = Position;
	oTexcoord2 = float4(CameraPosition - Position.xyz, oPosition.w);
}

GbufferParam MaterialPS(
	in float3 normal   : TEXCOORD0,
	in float2 coord    : TEXCOORD1,
	in float4 worldPos : TEXCOORD2,
	in float4 viewdir  : TEXCOORD3)
{
	MaterialParam material = (MaterialParam)0;
	material.albedo = scatteringLow;
	material.normal = GetWaveNormal(coord, normal, normalize(viewdir.xyz));
	material.smoothness = smoothness;
	material.specular = smoothnessBaseSpecular;
	material.customDataA = 0;
	material.customDataB = scatteringHigh;
	material.emissive = 0.0;
	material.emissiveIntensity = 0.0;
	material.visibility = 0.0;
	material.lightModel = SHADINGMODELID_GLASS;
	material.alpha = MaterialDiffuse.a;

	return EncodeGbuffer(material, viewdir.w);
}

#define OBJECT_TEC(name, mmdpass) \
	technique name < string MMDPass = mmdpass; \
	string Script = \
		"RenderColorTarget0=Gbuffer5RT;" \
		"RenderColorTarget1=Gbuffer6RT;" \
		"RenderColorTarget2=Gbuffer7RT;" \
		"RenderColorTarget3=Gbuffer8RT;" \
		"Pass=DrawObject;"\
	;> { \
		pass DrawObject { \
			AlphaTestEnable = false; AlphaBlendEnable = false; \
			VertexShader = compile vs_3_0 MaterialVS(); \
			PixelShader  = compile ps_3_0 MaterialPS(); \
		} \
	}

OBJECT_TEC(MainTec0, "object")
OBJECT_TEC(MainTecBS0, "object_ss")

technique EdgeTec < string MMDPass = "edge"; > {}
technique ShadowTech < string MMDPass = "shadow";  > {}
technique ZplotTec < string MMDPass = "zplot"; > {}