float time : TIME;//<bool SyncInEditMode=true;>;

float4x4 matView : VIEW;
float4x4 matViewProject : VIEWPROJECTION;

float3 CameraPosition  : POSITION  < string Object = "Camera"; >;

float4 MaterialDiffuse : DIFFUSE  < string Object = "Geometry"; >;

#define TEXTURE_FILTER ANISOTROPIC
#define TEXTURE_MIP_FILTER ANISOTROPIC
#define TEXTURE_ANISOTROPY_LEVEL 16

#define SHADINGMODELID_GLASS 4

#define MIDPOINT_8_BIT (127.0f / 255.0f)
#define MAX_FRACTIONAL_8_BIT (255.0f / 256.0f)
#define TWO_BITS_EXTRACTION_FACTOR (3.0f + MAX_FRACTIONAL_8_BIT)

shared texture Gbuffer2RT: RENDERCOLORTARGET;
shared texture Gbuffer3RT: RENDERCOLORTARGET;
shared texture Gbuffer4RT: RENDERCOLORTARGET;
shared texture Gbuffer5RT: RENDERCOLORTARGET;
shared texture Gbuffer6RT: RENDERCOLORTARGET;
shared texture Gbuffer7RT: RENDERCOLORTARGET;
shared texture Gbuffer8RT: RENDERCOLORTARGET;

#if WAVE_MAP_ENABLE
	texture WaveNormalMap<string ResourceName = WAVE_MAP_FILE;>; 
	sampler WaveNormalMapSamp = sampler_state
	{
		texture = WaveNormalMap;
		MAXANISOTROPY = TEXTURE_ANISOTROPY_LEVEL;
		MINFILTER = TEXTURE_FILTER; MAGFILTER = TEXTURE_FILTER; MIPFILTER = TEXTURE_MIP_FILTER;
		ADDRESSU = WRAP; ADDRESSV = WRAP;
	};
#endif

#if WAVE_FLOW_MAP_ENABLE
	texture WaveFlowMap<string ResourceName = WAVE_FLOW_MAP_FILE;>; 
	sampler WaveFlowMapSamp = sampler_state
	{
		texture = WaveFlowMap;
		MAXANISOTROPY = TEXTURE_ANISOTROPY_LEVEL;
		MINFILTER = TEXTURE_FILTER; MAGFILTER = TEXTURE_FILTER; MIPFILTER = TEXTURE_MIP_FILTER;
		ADDRESSU = WRAP; ADDRESSV = WRAP;
	};
#endif

#if WAVE_FOAM_MAP_ENABLE
	texture WaveFoamMap<string ResourceName = WAVE_FOAM_MAP_FILE;>; 
	sampler WaveFoamMapSamp = sampler_state
	{
		texture = WaveFoamMap;
		MAXANISOTROPY = TEXTURE_ANISOTROPY_LEVEL;
		MINFILTER = TEXTURE_FILTER; MAGFILTER = TEXTURE_FILTER; MIPFILTER = TEXTURE_MIP_FILTER;
		ADDRESSU = WRAP; ADDRESSV = WRAP;
	};
#endif

#if WAVE_RIPPLE_MAP_ENABLE
	texture RippleNormalMap<string ResourceName = WAVE_RIPPLE_MAP_FILE;>; 
	sampler RippleNormalMapSamp = sampler_state
	{
		texture = RippleNormalMap;
		MAXANISOTROPY = TEXTURE_ANISOTROPY_LEVEL;
		MINFILTER = TEXTURE_FILTER; MAGFILTER = TEXTURE_FILTER; MIPFILTER = TEXTURE_MIP_FILTER;
		ADDRESSU = WRAP; ADDRESSV = WRAP;
	};
#endif

struct MaterialParam
{
	float3 normal;
	float3 albedo;
	float3 specular;
	float3 emissive;
	float emissiveIntensity;
	float smoothness;
	float alpha;
	float visibility;
	float customDataA;
	float3 customDataB;
	int lightModel;
};

struct GbufferParam
{
	float4 buffer1 : COLOR0;
	float4 buffer2 : COLOR1;
	float4 buffer3 : COLOR2;
	float4 buffer4 : COLOR3;
};

float3 EncodeNormal(float3 normal)
{
	float p = sqrt(-normal.z * 8 + 8);
	float2 enc = normal.xy / p + 0.5f;
	float2 enc255 = enc * 255;
	float2 residual = floor(frac(enc255) * 16);
	return float3(floor(enc255), residual.x * 16 + residual.y) / 255;
}

float3 rgb2ycbcr(float3 col)
{
	float3 encode;
	encode.x = dot(float3(0.299, 0.587, 0.114),   col.rgb);
	encode.y = dot(float3(-0.1687, -0.3312, 0.5), col.rgb);
	encode.z = dot(float3(0.5, -0.4186, -0.0813), col.rgb);
	return half3(encode.x, encode.y * MIDPOINT_8_BIT + MIDPOINT_8_BIT, encode.z * MIDPOINT_8_BIT + MIDPOINT_8_BIT);
}

float3 ComputeTangentBinormalNormal(float3 N, float3 viewdir, float2 coord, float3 tangentNormal)
{
	float3 dp1 = ddx(viewdir);
	float3 dp2 = ddy(viewdir);
	float2 duv1 = ddx(coord);
	float2 duv2 = ddy(coord);

	float3x3 M = float3x3(dp1, dp2, N);
	float2x3 I = float2x3(cross(M[1], M[2]), cross(M[2], M[0]));
	float3 T = mul(float2(duv1.x, duv2.x), I);
	float3 B = mul(float2(duv1.y, duv2.y), I);

	float scaleT = 1.0f / (dot(T, T) + 1e-6);
	float scaleB = 1.0f / (dot(B, B) + 1e-6);

	float3x3 tbnTransform;
	tbnTransform[0] = normalize(T * scaleT);
	tbnTransform[1] = normalize(B * scaleB);
	tbnTransform[2] = N;

	return normalize(mul(tangentNormal, tbnTransform));
}

GbufferParam EncodeGbuffer(MaterialParam material, float linearDepth)
{
	GbufferParam gbuffer;
	gbuffer.buffer1.xyz = material.albedo;
	gbuffer.buffer1.w = material.smoothness;

	material.normal = mul(material.normal, (float3x3)matView);
	material.normal = normalize(material.normal);

	gbuffer.buffer2.xyz = EncodeNormal(material.normal);
	gbuffer.buffer2.w = material.customDataA;

	gbuffer.buffer3.xyz = rgb2ycbcr(material.specular);
	gbuffer.buffer3.w = 0;

	material.customDataB = rgb2ycbcr(min(0.999, material.customDataB));
	gbuffer.buffer3.yz = material.customDataB.gb;
	gbuffer.buffer3.w = material.customDataB.r * MAX_FRACTIONAL_8_BIT;
	gbuffer.buffer3.w = gbuffer.buffer3.w / TWO_BITS_EXTRACTION_FACTOR;

	gbuffer.buffer4 = float4(linearDepth, material.emissiveIntensity, material.lightModel, material.alpha);    
	gbuffer.buffer4.y = floor(material.emissiveIntensity * 100.0) + saturate(material.visibility) - 1e-5;

	return gbuffer;
}

texture NoiseMap<string ResourceName = "textures/noise.png"; int Miplevels = 0;>; 
sampler NoiseMapSamp = sampler_state {
	texture = <NoiseMap>;
	MINFILTER = LINEAR; MAGFILTER = LINEAR; MIPFILTER = NONE;
	ADDRESSU = WRAP; ADDRESSV = WRAP;
};

float noise(float2 x) 
{
	return tex2Dlod(NoiseMapSamp, float4(x / 256, 0, 0)).x;
}

float noise(float3 x)
{
	float3 p = floor(x);
	float3 f = frac(x);
	f = f * f * (3.0 - 2.0 * f);

	float2 uv = (p.xy + float2(37.0, 17.0) * p.z) + f.xy;
	float2 rg = tex2Dlod(NoiseMapSamp, float4((uv + 0.5) / 256.0, 0, 0)).yx;
	return lerp(rg.x, rg.y, f.z);
}

float fbm(float2 p) 
{
	float2x2 m2 = float2x2(1.6,-1.2,1.2,1.6);
	float f = 0;
	f += 0.5000 * noise( p ); p = mul(m2, p);
	f += 0.2500 * noise( p ); p = mul(m2, p);
	f += 0.1666 * noise( p ); p = mul(m2, p);
	f += 0.0834 * noise( p );
	return f;
}

float GetWaveHeight(float2 p, float height, float small, float large, float time)
{
	float2 shift1 = 0.001 * float2(time * 160.0,  time * 120.0) * 2.0 * 0.3;
	float2 shift2 = 0.001 * float2(time * 190.0, -time * 130.0) * 2.0;

	float wave = 0.0;
	wave += sin(p.x*0.021 + shift2.x)*4.5;
	wave += sin(dot(p, float2(0.0172, 0.010))    + shift2.x * 1.121) * 4.0;
	wave -= sin(dot(p, float2(0.00104, 0.005))   + shift2.x * 2.121) * 4.0;
	wave += sin(dot(p, float2(0.02221, 0.01233)) + shift2.x * 3.437) * 5.0;
	wave += sin(dot(p, float2(0.03112, 0.01122)) + shift2.x * 4.269) * 2.5;
	wave *= large;

	wave -= fbm(p * 2e-4 * 0.25) * small * 24.0;

	float amp = 6 * small;
	float2x2 m2 = float2x2(1.6,-1.2,1.2,1.6);

	for (int i = 0; i < 7; i++)
	{
		wave -= abs(sin((noise(p*0.01+shift1)-0.5) * 3.1415926)) * amp;
		amp *= 0.51;
		shift1 *= 1.841;
		p = mul(m2, p) * 0.9331;
	}

	height += wave;
	return height;
}

float3 GetWaveNormal(float3 P, float3 V)
{
	float2 off_x = float2(1, 0) * 0.4;
	float2 off_y = float2(0, 1) * 0.4;

	float xl = GetWaveHeight((P.xz * 10 - off_x), 100.0, 1.0, 1.0, time);
	float xr = GetWaveHeight((P.xz * 10 + off_x), 100.0, 1.0, 1.0, time);
	float ut = GetWaveHeight((P.xz * 10 - off_y), 100.0, 1.0, 1.0, time);
	float ub = GetWaveHeight((P.xz * 10 + off_y), 100.0, 1.0, 1.0, time);
	float3 N = normalize(lerp(float3(0,1,0), float3(xl - xr, 1.0, ut - ub), abs(V.y)));

	return N;
}

float GetWaveCurvature(float3 P, float2 coord)
{
    float L = length(coord * 2 - 1);
    L = 1 - smoothstep(0.7, 1.5, L);
	float xc = GetWaveHeight((P.xz * 10), 100.0, 1.0, 2.0, time);
	return exp((xc - 100) * 0.025) * L;
}

void MaterialVS(
	in float4 Position : POSITION, 
	in float3 Normal : NORMAL, 
	in float2 Texcoord: TEXCOORD0,
	out float3 oNormal   : TEXCOORD0,
	out float3 oTexcoord : TEXCOORD1,
	out float4 oWorldPos : TEXCOORD2,
	out float4 oPosition : POSITION)
{
	oNormal = Normal;
	oWorldPos = Position;
	oPosition = mul(Position, matViewProject);
	oTexcoord = float3(Texcoord, oPosition.w);
}

GbufferParam MaterialPS(
	in float3 normal   : TEXCOORD0,
	in float3 coord    : TEXCOORD1,
	in float3 worldPos : TEXCOORD2)
{
	MaterialParam material = (MaterialParam)0;
	material.albedo = scatteringLow;
	material.normal = GetWaveNormal(worldPos, normalize(worldPos - CameraPosition));
	material.smoothness = smoothness;
	material.specular = smoothnessBaseSpecular;
	material.customDataA = GetWaveCurvature(worldPos, coord.xy);
	material.customDataB = scatteringHigh;
	material.emissive = 0.0;
	material.emissiveIntensity = 0.0;
	material.visibility = 0.0;
	material.lightModel = SHADINGMODELID_GLASS;
	material.alpha = MaterialDiffuse.a;

	return EncodeGbuffer(material, coord.z);
}

#define OBJECT_TEC(name, mmdpass) \
	technique name < string MMDPass = mmdpass; \
	string Script = \
		"RenderColorTarget0=Gbuffer5RT;" \
		"RenderColorTarget1=Gbuffer6RT;" \
		"RenderColorTarget2=Gbuffer7RT;" \
		"RenderColorTarget3=Gbuffer8RT;" \
		"Pass=DrawObject;"\
	;> { \
		pass DrawObject { \
			AlphaTestEnable = false; AlphaBlendEnable = false; \
			VertexShader = compile vs_3_0 MaterialVS(); \
			PixelShader  = compile ps_3_0 MaterialPS(); \
		} \
	}

OBJECT_TEC(MainTec0, "object")
OBJECT_TEC(MainTecBS0, "object_ss")

technique EdgeTec < string MMDPass = "edge"; > {}
technique ShadowTech < string MMDPass = "shadow";  > {}
technique ZplotTec < string MMDPass = "zplot"; > {}