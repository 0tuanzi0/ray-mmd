#include "../shader/math.fx"
#include "../shader/common.fx"
#include "../shader/gbuffer.fx"
#include "../shader/gbuffer_sampler.fx"
#include "../shader/lighting.fx"

#ifndef AlphaThreshold
#   define AlphaThreshold 0.5
#endif

texture ObjectTexture: MATERIALTEXTURE;
sampler ObjTexSampler = sampler_state
{
    texture = <ObjectTexture>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = LINEAR;
    MAXANISOTROPY = 16;
    ADDRESSU = WRAP;
    ADDRESSV = WRAP;
};

texture SphereMap : MATERIALSPHEREMAP;
sampler SphereMapSamp = sampler_state {
    texture = <SphereMap>;
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
};

texture ToneMap : MATERIALTOONTEXTURE;
sampler ToneMapSamp = sampler_state {
    texture = <ToneMap>;
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
};

struct VS_OUTPUT
{
    float4 Position : POSITION;
    float3 Normal   : TEXCOORD0;
    float2 Texcoord : TEXCOORD1;
    float  Distance : TEXCOORD2;
    float3 Viewdir  : TEXCOORD3; 
};

struct PS_OUTPUT
{
    float4 Gbuffer1 : COLOR0;
    float4 Gbuffer2 : COLOR1;
    float4 Gbuffer3 : COLOR2;
};

float3 ColorSynthesis(float3 diffuse, float m)
{
    float3 melanin = diffuse * luminance(diffuse);
    return diffuse * lerp(1.0, melanin, m);
}

float3 SkinTransmittance(float translucency)
{
    return exp((1 - saturate(translucency)) * float3(-8, -40, -64));
}

float4 GetTextureColor(float4 albedo, float2 uv, bool use_texture)
{
    if (use_texture)
    {
        float4 TexColor = tex2D(ObjTexSampler, uv);
        TexColor.rgb = lerp(1, TexColor * TextureMulValue + TextureAddValue, TextureMulValue.a + TextureAddValue.a).rgb;
        TexColor.rgb = TexColor.rgb;
        albedo *= TexColor;
    }

    return albedo;
}

float3 GetNormal(float3 N, float3 viewdir, float2 coord)
{
#if defined(SPHEREMAP_RGB_AS_NORMAL)
    float3x3 tangentFrame = computeTangentBinormalNormal(N, viewdir, coord);    
    float3 tangentNormal = normalize(tex2D(SphereMapSamp, coord).rgb * 2 - 1);
    float3 highNormal = normalize(mul(tangentNormal, tangentFrame));
    return highNormal;
#else
    return N;
#endif
}

float GetSmoothness(float2 coord)
{
#if defined(TONEMAP_RED_AS_ROUGHNESS)
    return RoughnessToSmoothness(tex2D(ToneMapSamp, coord).r);
#elif defined(TONEMAP_GREEN_AS_ROUGHNESS)
    return RoughnessToSmoothness(tex2D(ToneMapSamp, coord).g);
#elif defined(TONEMAP_BLUE_AS_ROUGHNESS)
    return RoughnessToSmoothness(tex2D(ToneMapSamp, coord).b);
#elif defined(TONEMAP_ALPHA_AS_ROUGHNESS)
    return RoughnessToSmoothness(tex2D(ToneMapSamp, coord).a);
#elif defined(SPHEREMAP_ALPHA_AS_ROUGHNESS)
    return RoughnessToSmoothness(tex2D(SphereMap, coord).a);
#elif defined(TONEMAP_RED_AS_SMOOTHNESS)
    return tex2D(ToneMapSamp, coord).r;
#elif defined(TONEMAP_GREEN_AS_SMOOTHNESS)
    return tex2D(ToneMapSamp, coord).g;
#elif defined(TONEMAP_BLUE_AS_SMOOTHNESS)
    return tex2D(ToneMapSamp, coord).b;
#elif defined(TONEMAP_ALPHA_AS_SMOOTHNESS)
    return tex2D(ToneMapSamp, coord).a;
#elif defined(SPHEREMAP_ALPHA_AS_SMOOTHNESS)
    return tex2D(SphereMap, coord).a;
#elif defined(USE_CUSTOM_MATERIAL)
    return smoothness;
#else
    return ShininessToSmoothness(MaterialPower);
#endif
}

float GetMetalness(float2 coord)
{
#if defined(TONEMAP_RED_AS_METALNESS)
    return tex2D(ToneMapSamp, coord).r;
#elif defined(TONEMAP_GREEN_AS_METALNESS)
    return tex2D(ToneMapSamp, coord).g;
#elif defined(TONEMAP_BLUE_AS_METALNESS)
    return tex2D(ToneMapSamp, coord).b;
#elif defined(TONEMAP_ALPHA_AS_METALNESS)
    return tex2D(ToneMapSamp, coord).a;
#elif defined(SPHEREMAP_ALPHA_AS_METALNESS)
    return tex2D(SphereMap, coord).a;
#elif defined(USE_CUSTOM_MATERIAL)
    return metalness;
#else
    return 0.0f;
#endif
}

VS_OUTPUT MaterialVS(float4 Position : POSITION, float3 Normal : NORMAL, float2 Texcoord: TEXCOORD0)
{
    VS_OUTPUT Out;
    Out.Position = mul(Position, matWorldViewProject);
    Out.Normal = normalize(mul(Normal, (float3x3)matWorldView));
    Out.Texcoord = Texcoord;
    Out.Distance = Out.Position.w;
    Out.Viewdir = mul(CameraPosition - mul(Position, matWorld).xyz, (float3x3)matView);
    return Out;
}

GbufferParam MaterialPS(VS_OUTPUT IN, uniform bool useTexture, uniform bool useSphereMap)
{
    float4 albedo = GetTextureColor(MaterialDiffuse, IN.Texcoord, useTexture);
    albedo.rgb = ColorSynthesis(albedo.rgb, melanin);

    clip(albedo.a - AlphaThreshold);

    MaterialParam material;
    material.normal = GetNormal(normalize(IN.Normal), normalize(-IN.Viewdir), IN.Texcoord);
    material.index = 0;

#if defined(ENABLE_EMMISIVE)
    material.lightModel = LIGHTINGMODEL_EMISSIVE;
#else
    material.lightModel = LIGHTINGMODEL_NORMAL;
#endif

    #if defined(USE_CUSTOM_MATERIAL)
        float MaterialMetalness = GetMetalness(IN.Texcoord);

        material.albedo = albedo.rgb * (1.0 - MaterialMetalness);
        material.specular = lerp(reflection.rgb, albedo.rgb, MaterialMetalness);
        material.smoothness = GetSmoothness(IN.Texcoord);
        
        #if defined(ENABLE_SSS_SKIN)
            #if defined(TONEMAP_AHLPA_AS_METALNESS)
                material.transmittance = SkinTransmittance(translucency) * albedo.a;
            #else
                material.transmittance = SkinTransmittance(translucency) * (1.0 - MaterialMetalness);
            #endif
            material.lightModel = LIGHTINGMODEL_TRANSMITTANCE;
            material.index = SUBSURFACESCATTERING_SKIN;
        #elif defined(ENABLE_SSS)
            #if defined(TONEMAP_AHLPA_AS_METALNESS)
                material.transmittance = transmittance * (1.0 - albedo.a);
            #else
                material.transmittance = transmittance * (1.0 - MaterialMetalness);
            #endif
            material.lightModel = LIGHTINGMODEL_TRANSMITTANCE;
            material.index = SUBSURFACESCATTERING_MARBLE;
        #endif
    #else
        float MaterialMetalness = GetMetalness(IN.Texcoord);
        
        float3 dielectricColor = float3(0.04, 0.04, 0.04);

        material.albedo = albedo.rgb * (1 - MaterialMetalness);
        material.transmittance = 0.0f;
        material.specular = lerp(max(dielectricColor, MaterialSpecular), albedo.rgb, MaterialMetalness);
        material.smoothness = GetSmoothness(IN.Texcoord);
    #endif

    return EncodeGbuffer(material, IN.Distance);
}

#define OBJECT_TEC(name, mmdpass, tex, sphere) \
    technique name < string MMDPass = mmdpass; bool UseTexture = tex; bool UseSphereMap = sphere; \
    string Script = \
        "RenderColorTarget0=;" \
        "RenderColorTarget1=Gbuffer2RT;" \
        "RenderColorTarget2=Gbuffer3RT;" \
        "RenderColorTarget3=Gbuffer4RT;" \
        "RenderDepthStencilTarget=;" \
        "Pass=DrawObject;" \
        "RenderColorTarget1=;" \
        "RenderColorTarget2=;" \
    ; \
    > { \
        pass DrawObject { \
            AlphaTestEnable = FALSE; AlphaBlendEnable = FALSE; \
            VertexShader = compile vs_3_0 MaterialVS(); \
            PixelShader  = compile ps_3_0 MaterialPS(tex, sphere); \
        } \
    }

OBJECT_TEC(MainTec0, "object", false, false)
OBJECT_TEC(MainTec1, "object", true, false)
OBJECT_TEC(MainTec2, "object", false, true)
OBJECT_TEC(MainTec3, "object", true, true)
OBJECT_TEC(MainTecBS0, "object_ss", false, false)
OBJECT_TEC(MainTecBS1, "object_ss", true, false)
OBJECT_TEC(MainTecBS2, "object_ss", false, true)
OBJECT_TEC(MainTecBS3, "object_ss", true, true)

technique EdgeTec < string MMDPass = "edge"; > {}
technique ShadowTech < string MMDPass = "shadow";  > {}
technique ZplotTec < string MMDPass = "zplot"; > {}