#define NUM_SAMPLES_STEP 8
#define NUM_SAMPLES_STEP2 4

struct ScatteringParams
{
	float sunSize;
	float sunRadiance;

	float mieG;
	float mieHeight;

	float rayleighHeight;

	float3 waveLambda;
	float3 waveLambdaMie;
	float3 waveLambdaRayleigh;

	float earthRadius;
	float earthAtmTopRadius;
	float3 earthCenter;

	float cloud;
	float cloudMie;
	float cloudBias;
	float cloudTop;
	float cloudBottom;
	float3 clouddir;
};

float3 ComputeWaveLengthMie(float density)
{
	return 2e-5f * density;
}

float3 ComputeWaveLengthMie(float3 lambda, float3 K, float T, float V)
{
	float c_pi = (0.6544 * T - 0.6510) * 1e-16 * PI;
	float mieConst = 0.434 * c_pi * pow(2.0 * PI, V - 2.0);
	return mieConst * K / pow(lambda, V - 2);
}

float3 ComputeWaveLengthRayleigh(float3 lambda)
{
	static const float n = 1.0003;
	static const float N = 2.545E25;
	static const float pn = 0.035;
	static const float n2 = n * n;
	static const float pi3 = PI * PI * PI;
	static const float rayleighConst = (8.0 * pi3 * pow2(n2 - 1.0)) / (3 * N) * ((6 + 3 * pn) / (6 - 7 * pn));
	return rayleighConst / (lambda * lambda * lambda * lambda);
}

float ComputeOpticalMass(float cosAngle)
{
	float cosAngleRadians = degrees(acos(cosAngle));
	return 1.0 / (cosAngle + 0.15 * pow(abs(93.885 - cosAngleRadians), -1.253));
}

float ComputePhaseMie(float theta, float g)
{
	float g2 = g * g;

	float theta2 = theta * theta;

	float leftTop = 3.0 * (1.0 - g2);
	float leftBottom = 2.0 * (2.0 + g2);
	float rightTop = 1.0 + theta2;
	float rightBottom = pow(saturate(1.0 + g2 - 2.0 * g * theta), 1.5);

	return ((leftTop / leftBottom) * (rightTop / rightBottom)) / (4.0 * PI);
}

float ComputePhaseRayleigh(float theta)
{
	float theta2 = theta * theta;
	return (theta2 * 0.75 + 0.75) / (4.0 * PI);
}

float3 ComputeScatteringFunctions(float3 inscatteringMie, float3 inscatteringRayleigh, float3 V, float3 L, float g)
{
	float cosTheta = dot(V, L);

	float3 betaMie = inscatteringMie * ComputePhaseMie(cosTheta, g);
	float3 betaRayleigh = inscatteringRayleigh * ComputePhaseRayleigh(cosTheta);

	float3 betaTotal = (betaMie + betaRayleigh);
	return betaTotal / (inscatteringMie + inscatteringRayleigh);
}

float3 ComputeScatteringFunctions(float3 inscatteringMie, float3 inscatteringRayleigh, float3 V, float3 L, float g, float g2, float clound)
{
	float sunTheta = dot(V, L);
	float sunFade = pow(saturate(V.y), 1.0 / 2.2);

	float3 betaMie1 = inscatteringMie * ComputePhaseMie(sunTheta, g);
	float3 betaMie2 = inscatteringMie * ComputePhaseMie(sunTheta, g2) * (1 - saturate(clound));
	float3 betaRayleigh = inscatteringRayleigh * ComputePhaseRayleigh(sunTheta);

	float3 betaTotal = (betaMie1 + betaMie2 * sunFade + betaRayleigh);
	return betaTotal / (inscatteringMie + inscatteringRayleigh);
}

float ComputeSunIntensity(float EE, float zenithAngleCos)
{
	float steepness = 1.0;
	float cutoffAngle = PI / 1.95;
	return EE * saturate(1.0f - exp(-((cutoffAngle - acos(zenithAngleCos)) / steepness)));
}

float3 ComputeSkyFog(ScatteringParams setting, float distance, float3 V, float3 L)
{
	float3 up = float3(0, 1, 0);
	float3 sunDirection = normalize(-L);

	float zenithAngle = saturate(dot(V, up));
	float zenithAngleCos = dot(sunDirection, up);
	float zenithAngleMass = ComputeOpticalMass(zenithAngle);

	float3 inscatteringMie = setting.waveLambdaMie;
	float3 inscatteringRayleigh = setting.waveLambdaRayleigh - saturate(1.0 - exp(sunDirection.y));

	float3 inscattering = ComputeScatteringFunctions(inscatteringMie, inscatteringRayleigh, V, sunDirection, setting.mieG);

	float3 scatteringMie = inscatteringMie * distance;
	float3 scatteringRayleigh = inscatteringRayleigh * distance;
	float3 extinction = exp(-(scatteringMie + scatteringRayleigh));

	inscattering *= ComputeSunIntensity(setting.sunRadiance, zenithAngleCos);

	float3 Lin = inscattering * (1.0 - extinction) * (4 * PI);
	return Lin;
}

float2 ComputeRaySphereIntersection(float3 position, float3 dir, float3 center, float radius)
{
	float3 origin = position - center;
	float B = dot(origin, dir);
	float C = dot(origin, origin) - radius * radius;
	float D = B * B - C;

	float2 minimaxIntersections;
	if (D < 0.0)
	{
		minimaxIntersections = float2(-1.0, -1.0);
	}
	else
	{
		D = sqrt(D);
		minimaxIntersections = float2(-B - D, -B + D);
	}

	return minimaxIntersections;
}

void ComputeOpticalLength(ScatteringParams setting, float3 P, out float2 opticalLength)
{
	float height = length(P - setting.earthCenter) - setting.earthRadius;
	opticalLength = exp(-height / float2(setting.mieHeight, setting.rayleighHeight));
}

void ComputeOpticalInsctrIntegral(ScatteringParams setting, float3 start, float3 end, out float2 opticalLength)
{
	float3 sampleStep = (end - start) / float(NUM_SAMPLES_STEP2);
	float3 samplePos = start;

	for (int j = 0; j < NUM_SAMPLES_STEP2; ++j, samplePos += sampleStep) 
	{
		float2 stepDepthLight;
		ComputeOpticalLength(setting, samplePos, stepDepthLight);
		opticalLength += stepDepthLight;
	}

	opticalLength *= length(sampleStep);
}

void ComputeInsctrIntegral(ScatteringParams setting, float3 start, float3 end, float3 V, float3 L, out float2 opticalLength, out float3 insctrMie, out float3 insctrRayleigh)
{
	float3 samplePos = start;
	float3 sampleStep = (end - start) / float(NUM_SAMPLES_STEP);
	float sampleLength = length(sampleStep);

	for (int i = 0; i < NUM_SAMPLES_STEP; ++i, samplePos += sampleStep)
	{
		float2 stepOpticalLength;
		ComputeOpticalLength(setting, samplePos, stepOpticalLength);
		stepOpticalLength *= sampleLength;

		float2 sampleLightIntersections = ComputeRaySphereIntersection(samplePos, L, setting.earthCenter, setting.earthAtmTopRadius);
		float3 sampleLight = samplePos + L * sampleLightIntersections.y;

		float2 stepOpticalLight = 0.0;
		ComputeOpticalInsctrIntegral(setting, samplePos, sampleLight, stepOpticalLight);

		opticalLength += stepOpticalLength.xy;

		float3 opticalDepthMie = setting.waveLambdaMie * (stepOpticalLight.x + opticalLength.x);
		float3 opticalDepthRayleigh = setting.waveLambdaRayleigh * (stepOpticalLight.y + opticalLength.y);
		float3 opticalDepth = exp(-(opticalDepthMie + opticalDepthRayleigh));

		insctrMie += opticalDepth * stepOpticalLength.x;
		insctrRayleigh += opticalDepth * stepOpticalLength.y;
	}
}

float4 ComputeSkyboxInscattering(ScatteringParams setting, float3 eye, float3 V, float3 L)
{
	float2 outerIntersections = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthAtmTopRadius);
	clip(outerIntersections.y);

	float2 innerIntersections = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthRadius);
	if (innerIntersections.x > 0)
	{
		outerIntersections.y = innerIntersections.x;
	}

	float3 start = eye + V * max(0, outerIntersections.x);
	float3 end = eye + V * outerIntersections.y;

	float3 insctrMie = 0.0;
	float3 insctrRayleigh = 0.0;
	float2 insctrOpticalLength = 0.0;
	ComputeInsctrIntegral(setting, start, end, V, -L, insctrOpticalLength, insctrMie, insctrRayleigh);

	float phaseTheta = dot(V, -L);
	float phaseMie = ComputePhaseMie(phaseTheta, setting.mieG);
	float phaseSun = ComputePhaseMie(phaseTheta, setting.sunSize);
	float phaseRayleigh = ComputePhaseRayleigh(phaseTheta);
	float phaseNight = 1.0 - saturate(insctrOpticalLength.x * EPSILON);

	float3 insctrTotalSun = insctrMie * setting.waveLambdaMie * phaseSun;
	float3 insctrTotalMie = insctrMie * setting.waveLambdaMie * phaseMie;
	float3 insctrTotalRayleigh = insctrRayleigh * setting.waveLambdaRayleigh * phaseRayleigh;

	float3 scattering = (insctrTotalSun + insctrTotalMie + insctrTotalRayleigh);

	bool intersectionTest = innerIntersections.x < 0.0 && innerIntersections.y < 0.0;

	return float4(scattering * setting.sunRadiance, phaseNight * intersectionTest);
}

float3 ComputeDensity(ScatteringParams setting, float depth)
{
	return exp(-setting.waveLambdaMie * depth) * (1 - exp(-setting.waveLambdaMie * 2 * depth));
}

float ComputeClound(ScatteringParams setting, float3 P)
{
	float cloud = 0.0;
	float height = length(P - setting.earthCenter) - setting.earthRadius;

	if (setting.cloudBottom < height && setting.cloudTop > height) 
	{
		float3 P2 = P + float3(23175.7, 0.0, 0.0) + setting.clouddir;
		cloud = fbm(P2 * 2e-5, setting.cloudBias);

		cloud = smoothstep(0.4104, 0.604, cloud) * 70.0f;
		cloud *= sin(PI * (height - setting.cloudBottom) / setting.cloudBottom);
		cloud *= setting.cloud;
	}

	return cloud;
}

float ComputeCloudInsctrIntegral(ScatteringParams setting, float3 start, float3 end)
{
	float3 sampleStep = (end - start) / float(NUM_SAMPLES_STEP);
	float3 samplePos = start;

	float thickness = 0;

	for (int j = 0; j < NUM_SAMPLES_STEP; ++j, samplePos += sampleStep) 
	{
		float stepDepthLight = ComputeClound(setting, samplePos);
		thickness += stepDepthLight;
	}

	return thickness * length(sampleStep);
}

void ComputeCloudsInsctrIntegral(ScatteringParams setting, float3 start, float3 end, float3 V, float3 L, out float opticalDepth, out float3 insctrMie)
{
	float3 samplePos = start;
	float3 sampleStep = (end - start) / float(NUM_SAMPLES_STEP);
	float sampleLength = length(sampleStep);

	float3 opticalDepthMie = 0.0;

	for (int i = 0; i < NUM_SAMPLES_STEP; ++i, samplePos += sampleStep)
	{
		float stepOpticalDensity = ComputeClound(setting, samplePos);
		stepOpticalDensity *= sampleLength;

		if (any(stepOpticalDensity))
		{
			float2 sampleCloudsIntersections = ComputeRaySphereIntersection(samplePos, L, setting.earthCenter, setting.earthRadius + setting.cloudTop);
			float3 sampleClouds = samplePos + L * sampleCloudsIntersections.y;
			
			float stepOpticalLight = ComputeCloudInsctrIntegral(setting, samplePos, sampleClouds);
			
			opticalDepthMie += stepOpticalDensity * ComputeDensity(setting, stepOpticalLight) * ComputeDensity(setting, opticalDepth);
			opticalDepth += stepOpticalDensity;
		}
	}

	insctrMie = opticalDepthMie;
}

float4 ComputeCloudsInscattering(ScatteringParams setting, float3 eye, float3 V, float3 L)
{
	float2 outerIntersections = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthAtmTopRadius);
	clip(outerIntersections.y);

	float2 innerIntersections = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthRadius);
	if (innerIntersections.x > 0)
	{
		outerIntersections.y = innerIntersections.x;
	}

	float3 start = eye + V * max(0, outerIntersections.x);
	float3 end = eye + V * outerIntersections.y;

	float3 insctrMie = 0.0;
	float3 insctrRayleigh = 0.0;
	float2 insctrOpticalLength = 0.0;
	ComputeInsctrIntegral(setting, start, end, V, -L, insctrOpticalLength, insctrMie, insctrRayleigh);

	float2 cloudsOuterIntersections = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthRadius + setting.cloudTop);
	float2 cloudsInnerIntersections = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthRadius + setting.cloudBottom);

	if (cloudsInnerIntersections.x > 0)
	{
		cloudsOuterIntersections.y = cloudsInnerIntersections.x;
	}

	float3 cloudsStart = eye + V * max(0, cloudsOuterIntersections.x);
	float3 cloudsEnd = eye + V * cloudsOuterIntersections.y;

	float3 cloudsMie = 0.0;
	float cloudsOpticalLength = 0.0;
	ComputeCloudsInsctrIntegral(setting, cloudsStart, cloudsEnd, V, -L, cloudsOpticalLength, cloudsMie);

	float phaseTheta = dot(V, -L);
	float phaseMie = ComputePhaseMie(phaseTheta, setting.mieG);
	float phaseSun = ComputePhaseMie(phaseTheta, setting.sunSize);
	float phaseCloud = ComputePhaseMie(phaseTheta, setting.cloudMie);
	float phaseRayleigh = ComputePhaseRayleigh(phaseTheta);
	float phaseNight = 1.0 - saturate(insctrOpticalLength.x * EPSILON);

	float3 insctrTotalSun = insctrMie * setting.waveLambdaMie * phaseSun;
	float3 insctrTotalMie = insctrMie * setting.waveLambdaMie * phaseMie;
	float3 insctrTotalRayleigh = insctrRayleigh * setting.waveLambdaRayleigh * phaseRayleigh;

	float3 sky = insctrTotalSun + insctrTotalMie + insctrTotalRayleigh;
	float3 cloud = cloudsMie * phaseCloud * setting.sunRadiance * (insctrTotalRayleigh + insctrTotalMie);
	
	float3 scattering = lerp(cloud, sky, exp(-0.0000001 * cloudsOpticalLength));
	scattering = lerp(sky, scattering, V.y * V.y);

	bool intersectionTest = innerIntersections.x < 0.0 && innerIntersections.y < 0.0;

	return float4(scattering * setting.sunRadiance, phaseNight * intersectionTest);
}