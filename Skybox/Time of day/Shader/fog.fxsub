#if ATM_CLOUD_ENABLE
texture NoiseMap<string ResourceName = "shader/textures/cloud.dds";>; 
sampler NoiseMapSamp = sampler_state {
	texture = <NoiseMap>;
	MINFILTER = LINEAR; MAGFILTER = LINEAR; MIPFILTER = NONE;
	ADDRESSU = WRAP; ADDRESSV = WRAP;
};

float ComputeClound(ScatteringParams setting, float3 P)
{
	float3 P1 = P + setting.clouddir;
	float3 P2 = P + setting.clouddir * 0.5;

	float cloud = 0.0;
	cloud += tex2Dlod(NoiseMapSamp, float4(P1.xz * 0.00009, 0, 0)).a;
	cloud += tex2Dlod(NoiseMapSamp, float4(P2.xz * 0.00006, 0, 0)).a;
	cloud += tex2Dlod(NoiseMapSamp, float4(P2.xz * 0.00003, 0, 0)).a;
	cloud *= setting.cloud;

	return cloud;
}

float HitCloudsTest(ScatteringParams setting, float3 eye, float3 V, float3 L)
{
	float2 cloudsOuterIntersections = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthRadius + setting.cloudTop);
	float2 cloudsInnerIntersections = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthRadius + setting.cloudBottom);

	if (cloudsInnerIntersections.y > 0)
		cloudsOuterIntersections.x = cloudsInnerIntersections.y;

	float3 cloudsStart = eye + V * max(0, cloudsOuterIntersections.x);
	float3 cloudsEnd = eye + V * cloudsOuterIntersections.y;

	return exp(-0.002 * ComputeClound(setting, cloudsStart));
}
#endif

float3 ComputeFogChapmanMie(ScatteringParams setting, float3 eye, float3 V, float3 L, float distance, float density)
{
	float3 start = eye - setting.earthCenter;
	float3 end = start + V * distance * density;

	float3 insctrMie = 0.0;
	float3 insctrRayleigh = 0.0;
	float3 insctrOpticalLength = 1;
	AerialPerspective(setting, start, end, V, L, V.y > 0 ? true : false, insctrOpticalLength, insctrMie, insctrRayleigh);

	float phaseTheta = dot(V, -L);
	float phaseMie = ComputePhaseMie(phaseTheta, setting.mieG);

	float3 insctrTotalMie = insctrMie * phaseMie;

	return insctrTotalMie * setting.sunRadiance;
}

float3 ComputeFogChapmanRayleigh(ScatteringParams setting, float3 eye, float3 V, float3 L, float distance, float density, float densityFar)
{
	float3 start = eye - setting.earthCenter;
	float3 end = start + V * distance * density;

	float3 insctrMie = 0.0;
	float3 insctrRayleigh = 0.0;
	float3 insctrOpticalLength = 1;
	AerialPerspective(setting, start, end, V, L, V.y > 0 ? true : false, insctrOpticalLength, insctrMie, insctrRayleigh);

	float phaseTheta = dot(V, -L);
	float phaseRayleigh = ComputePhaseRayleigh(phaseTheta);

	float3 insctrTotalRayleigh = insctrRayleigh * phaseRayleigh * distance * densityFar;

	return insctrTotalRayleigh * setting.sunRadiance;
}

float3 ComputeFogChapman(ScatteringParams setting, float3 eye, float3 V, float3 L, float distance, float density, float densityFar)
{
	float3 start = eye - setting.earthCenter;
	float3 end = start + V * distance * density;

	float3 insctrMie = 0.0;
	float3 insctrRayleigh = 0.0;
	float3 insctrOpticalLength = 1;
	AerialPerspective(setting, start, end, V, L, V.y > 0 ? true : false, insctrOpticalLength, insctrMie, insctrRayleigh);

	float phaseTheta = dot(V, -L);
	float phaseMie = ComputePhaseMie(phaseTheta, setting.mieG);
	float phaseRayleigh = ComputePhaseRayleigh(phaseTheta);

	float3 insctrTotalMie = insctrMie * phaseMie;
	float3 insctrTotalRayleigh = insctrRayleigh * phaseRayleigh * distance * densityFar;

	float3 scattering = insctrTotalMie + insctrTotalRayleigh;

	return scattering * setting.sunRadiance;
}