float hash(float2 p) 
{ 
    return frac(sin(p.x) + cos(p.y)); 
}

float noise(float2 x) 
{
    float2 f = frac(x);
    float2 p = floor(x);

    float a = hash(p);
    float b = hash(p + float2(1.0, 0.0));
    float c = hash(p + float2(0.0, 1.0));
    float d = hash(p + float2(1.0, 1.0));

    float2 u = f * f * (3.0 - 2.0 * f);
    return lerp(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

float fbm(float2 p) 
{
    float f = 0; 
    f += 0.5000 * noise(p); p = p * 2.0;
    f += 0.2500 * noise(p); p = p * 2.0;
    f += 0.1250 * noise(p); p = p * 2.0;
    f += 0.0625 * noise(p); p = p * 2.0;
    f += 0.0312 * noise(p);
    return f;
}

float4 ComputeClound(float3 V, float3 color)
{
    float3 col = 0;
    
    float2 p = (CameraPosition.xz + V.xz * (250000.0 - CameraPosition.y) / V.y) * 0.000008;
    p += float2(0.3, -1.0) * time * 0.1;
    
    float fractal = fbm(p);
    float alpha = smoothstep(0.5, 0.8, fractal);
    alpha *= saturate(V.y);

    col = float3(1.0, 0.95, 1.0) * alpha;
    col *= 5;
    
    return float4(col, alpha);
}